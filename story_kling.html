<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BookWide - Story Kling JSON (5/10s)</title>
  <style>
    :root{
      --bg:#070b14;
      --panel:#0c1426;
      --border:rgba(255,255,255,.08);
      --muted:rgba(255,255,255,.65);
      --text:rgba(255,255,255,.92);
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", Arial, sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 600px at 20% -20%, rgba(85,140,255,.22), transparent 55%),
                  radial-gradient(900px 500px at 90% 10%, rgba(0,255,209,.10), transparent 55%),
                  radial-gradient(900px 500px at 40% 110%, rgba(255,142,0,.10), transparent 55%),
                  var(--bg);
      color:var(--text);
    }
    header{
      padding:18px 18px 8px;
      border-bottom:1px solid var(--border);
      background: linear-gradient(to bottom, rgba(255,255,255,.03), transparent);
    }
    header h1{ margin:0 0 6px; font-size:18px; letter-spacing:.2px; }
    header .sub{ margin:0; font-size:13px; color:var(--muted); line-height:1.4; }

    .wrap{
      display:grid;
      grid-template-columns: 410px 1fr;
      gap:16px;
      padding:16px;
      max-width: 1500px;
      margin:0 auto;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.03), transparent 18%),
                  var(--panel);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panel .hd{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .panel .hd .title{ font-size:14px; font-weight:700; margin:0; }
    .panel .hd .hint{ margin:2px 0 0; font-size:12px; color:var(--muted); }
    .panel .bd{ padding:14px; }

    .field{ margin: 0 0 12px; }
    .label{
      font-size:12px;
      color:var(--muted);
      margin:0 0 6px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .label b{ color:rgba(255,255,255,.85); font-weight:700; }

    input[type="file"]{
      width:100%;
      padding:10px;
      border-radius:12px;
      border:1px dashed rgba(255,255,255,.18);
      background: rgba(0,0,0,.20);
      color:var(--muted);
    }
    input[type="text"], input[type="number"], select, textarea{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      color:var(--text);
      outline:none;
    }
    textarea{
      min-height:88px;
      resize:vertical;
      font-family:var(--mono);
      font-size:12px;
      line-height:1.35;
    }
    textarea[readonly]{
      opacity:.95;
      background: rgba(0,0,0,.28);
    }
    .row2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      font-size:12px;
      color:rgba(255,255,255,.78);
      white-space:nowrap;
    }
    .btnrow{ display:flex; flex-wrap:wrap; gap:10px; margin-top:8px; }
    button{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:rgba(255,255,255,.92);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
      letter-spacing:.2px;
    }
    button.primary{
      background: linear-gradient(180deg, rgba(0,255,209,.18), rgba(0,255,209,.08));
      border-color: rgba(0,255,209,.25);
    }
    button.danger{
      background: linear-gradient(180deg, rgba(255,88,88,.18), rgba(255,88,88,.08));
      border-color: rgba(255,88,88,.25);
    }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .note{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      padding:10px 12px;
      border-radius:12px;
      font-size:12px;
      color:rgba(255,255,255,.78);
      line-height:1.4;
    }
    .note b{color:rgba(255,255,255,.90)}
    .smallmuted{ font-size:12px; color:var(--muted); }
    .mono{ font-family:var(--mono); }

    .rightTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:14px;
      border-bottom:1px solid var(--border);
    }
    .rightTop .meta{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      color:var(--muted);
      font-size:12px;
    }
    .grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(280px, 1fr));
      gap:14px;
      padding:14px;
    }
    @media (max-width:1200px){
      .wrap{ grid-template-columns: 1fr; }
      .grid{ grid-template-columns: repeat(2, minmax(240px, 1fr)); }
    }
    @media (max-width:720px){
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      border:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.03), transparent 30%),
                  rgba(0,0,0,.20);
      border-radius: var(--radius);
      overflow:hidden;
    }
    .thumb{ position:relative; background:#000; aspect-ratio: 16/9; overflow:hidden; }
    .thumb img{ width:100%; height:100%; object-fit:cover; display:block; filter:saturate(1.05) contrast(1.02); }
    .badgeRow{
      position:absolute;
      left:10px;
      bottom:10px;
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .badge{
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.16);
      color:rgba(255,255,255,.92);
      font-size:12px;
      backdrop-filter: blur(6px);
    }
    .cardBody{ padding:12px; }
    .capLine{
      font-size:13px;
      color:rgba(255,255,255,.90);
      line-height:1.35;
      margin:0 0 10px;
      min-height: 38px;
      white-space:pre-wrap;
    }
    .mini2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .miniLabel{ font-size:12px; color:var(--muted); margin: 0 0 6px; display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .miniTA{ min-height:78px; font-family:var(--mono); font-size:12px; }

    .finalWrap{ margin-top:10px; }
    .finalTA{ min-height:160px; }
    .copyLine{ display:flex; justify-content:flex-end; gap:10px; margin-top:8px; }
    .tinyBtn{
      padding:8px 10px;
      border-radius:12px;
      font-size:12px;
      font-weight:700;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:rgba(255,255,255,.92);
      cursor:pointer;
    }

    .sliderRow{
      display:flex;
      align-items:center;
      gap:10px;
    }
    input[type="range"]{
      width:100%;
      accent-color: #38f8d0;
    }
    .kv{
      font-family: var(--mono);
      font-size:12px;
      color: rgba(255,255,255,.85);
      white-space:nowrap;
      min-width: 64px;
      text-align:right;
    }
  </style>
</head>

<body>
<header>
  <h1>故事影片 → Kling 動畫提示 JSON（5/10 秒模式）</h1>
  <p class="sub">
    流程：匯入切好的圖片 → 匯入 SRT（依 min/max 秒合併 chunk）→ 產出每段「Kling 動畫提示」→ 匯出 JSON。<br/>
    <b>新功能：</b>自動判斷動態層級（Calm/Medium/Tension）＋ 全域/每段「強度滑桿」可調，最終 Prompt 即時更新並與 JSON 一致。
  </p>
</header>

<div class="wrap">
  <!-- LEFT -->
  <section class="panel">
    <div class="hd">
      <div>
        <p class="title">設定</p>
        <p class="hint">先選圖片與 SRT，再按「產生分鏡」。</p>
      </div>
      <span class="pill" id="statusPill">尚未產生</span>
    </div>

    <div class="bd">
      <div class="field">
        <p class="label"><b>1) 匯入切好的圖片</b><span class="smallmuted">多選：*_0001.jpg…</span></p>
        <input id="imgInput" type="file" accept="image/*" multiple />
        <div class="smallmuted" id="imgInfo" style="margin-top:6px;">尚未選擇圖片</div>
      </div>

      <div class="field">
        <p class="label"><b>2) 匯入 SRT</b><span class="smallmuted">會依 min/max 秒合併 chunk</span></p>
        <input id="srtInput" type="file" accept=".srt,text/plain" />
        <div class="smallmuted" id="srtInfo" style="margin-top:6px;">尚未選擇 SRT</div>
      </div>

      <div class="row2">
        <div class="field">
          <p class="label"><b>每段最短秒數（min）</b></p>
          <input id="minSec" type="number" min="1" step="1" value="10" />
        </div>
        <div class="field">
          <p class="label"><b>每段最長秒數（max）</b></p>
          <input id="maxSec" type="number" min="1" step="1" value="10" />
        </div>
      </div>

      <div class="field">
        <p class="label"><b>動態模式</b><span class="smallmuted">MP3 一律 10 秒不動</span></p>
        <select id="modeSelect">
          <option value="k5_to_10">Kling 5秒生成 → ffmpeg 拉長到 10秒（省成本）</option>
          <option value="k10" selected>Kling 10秒生成（不拉長）</option>
        </select>
        <div class="note" style="margin-top:8px;">
          <b>5→10 模式：</b>JSON 會輸出 <span class="mono">generate_sec=5</span>、<span class="mono">target_sec=10</span>、<span class="mono">stretch_factor=2.0</span><br/>
          <b>10 秒模式：</b><span class="mono">generate_sec=10</span>、<span class="mono">target_sec=10</span>、<span class="mono">stretch_factor=1.0</span>
        </div>
      </div>

      <div class="row2">
        <div class="field">
          <p class="label"><b>類別</b></p>
          <select id="catSelect">
            <option value="story">故事</option>
            <option value="movie">電影</option>
            <option value="music">音樂</option>
            <option value="news">新聞</option>
            <option value="grammar">文法</option>
          </select>
        </div>
        <div class="field">
          <p class="label"><b>風格（A/B/C/D/E）</b></p>
          <select id="styleSelect">
            <option value="A">A 童話風</option>
            <option value="B">B 歐美故事書風</option>
            <option value="C">C 寫實插畫風</option>
            <option value="D">D 家庭向動畫風（避開IP）</option>
            <option value="E">E 自訂</option>
          </select>
        </div>
      </div>

      <div class="field" id="customStyleWrap" style="display:none;">
        <p class="label"><b>自訂風格（E）</b><span class="smallmuted">會附加到每段提示尾巴</span></p>
        <input id="customStyle" type="text" value="original illustration, clean lines, warm color palette, cinematic lighting, high detail, no text" />
      </div>

      <div class="field">
        <p class="label"><b>全域畫面加成（會加到每段提示尾巴）</b></p>
        <textarea id="globalSuffix" placeholder="例如：cinematic lighting, professional color grading, subtle film grain, high detail, 4k"></textarea>
      </div>

      <div class="field">
        <p class="label"><b>全域音效（SFX）加成（會寫入每段 JSON）</b><span class="smallmuted">貼到 Kling 的「音效」欄</span></p>
        <textarea id="globalSfx" placeholder="例如：subtle ambient environment sound, light wind, soft cloth movement"></textarea>
        <div class="note" style="margin-top:8px;">
          <b>建議：</b>保持 <span class="mono">subtle / soft / gentle</span>，避免太強烈音效導致畫面節奏亂。
        </div>
      </div>

      <div class="field">
        <p class="label"><b>全域配樂（Music）加成（會寫入每段 JSON）</b><span class="smallmuted">貼到 Kling 的「配樂」欄</span></p>
        <textarea id="globalMusic" placeholder="例如：soft cinematic background music, gentle strings and piano, slow tempo"></textarea>
        <div class="note" style="margin-top:8px;">
          <b>建議：</b>故事型用慢節奏敘事配樂，避免 EDM / 強鼓點。
        </div>
      </div>


      <!-- ✅ 新增：全域強度滑桿 -->
      <div class="field">
        <p class="label">
          <b>全域動態強度（Auto + Slider）</b>
          <span class="smallmuted">0.0=幾乎不動｜1.0=正常｜2.0=更明顯（仍是微動作）</span>
        </p>
        <div class="sliderRow">
          <input id="globalIntensity" type="range" min="0" max="2" step="0.05" value="1" />
          <div class="kv" id="globalIntensityVal">1.00</div>
        </div>
        <div class="note" style="margin-top:8px;">
          <b>說明：</b>每段先依 narration 自動判斷 Calm/Medium/Tension，再乘上你這個全域強度。
          你也可以在每張卡片再單獨微調。
        </div>
      </div>

      <div class="btnrow">
        <button class="primary" id="buildBtn">產生分鏡</button>
        <button id="applyDefaultBtn">重置動態基底/運鏡</button>
        <button id="copyJsonBtn" disabled>複製 JSON</button>
        <button class="primary" id="downloadJsonBtn" disabled>下載 JSON</button>
        <button class="danger" id="clearBtn">清空</button>
      </div>

      <div class="note" style="margin-top:12px;">
        <b>命名規則（你要跟圖片同名）：</b><br/>
        Kling 影片請放：<span class="mono">motion_raw\BASE\BASE_0001.mp4</span>（與圖片同名，只差副檔名）
      </div>
    </div>
  </section>

  <!-- RIGHT -->
  <section class="panel">
    <div class="rightTop">
      <div>
        <div style="font-weight:800; font-size:14px;">分鏡清單</div>
        <div class="smallmuted">每段自動判斷動態層級 + 強度滑桿（全域/每段）可調。最終 Prompt 與 JSON 一致。</div>
      </div>
      <div class="meta">
        <span class="pill" id="countPill">分鏡：0</span>
        <span class="pill" id="modePill">模式：—</span>
        <span class="pill" id="durPill">Kling：—</span>
      </div>
    </div>
    <div class="grid" id="cards"></div>
  </section>
</div>

<script>
  const state = {
    images: [], // {name, url, file}
    srtText: "",
    cues: [],
    chunks: [],
    shots: [],
    baseName: ""
  };

  const el = (id)=>document.getElementById(id);
  const pad4 = (n)=>String(n).padStart(4,'0');

  function sortByName(a,b){
    return a.name.localeCompare(b.name, undefined, {numeric:true, sensitivity:'base'});
  }
  function safeBaseFromImages(images){
    if(!images.length) return "";
    const n = images[0].name;
    const m = n.match(/^(.*)_\d{4}\.(jpg|jpeg|png|webp)$/i);
    if(m) return m[1];
    return n.replace(/\.[^.]+$/,'');
  }
  function setStatus(text){ el("statusPill").textContent = text; }

  function parseSrtTime(t){
    const m = t.trim().match(/(\d+):(\d+):(\d+)[,\.](\d+)/);
    if(!m) return 0;
    const hh = parseInt(m[1],10), mm=parseInt(m[2],10), ss=parseInt(m[3],10), ms=parseInt(m[4],10);
    return hh*3600 + mm*60 + ss + ms/1000;
  }
  function parseSrt(text){
    const blocks = text.replace(/\r/g,'').trim().split(/\n\s*\n/);
    const cues = [];
    for(const b of blocks){
      const lines = b.split('\n').map(x=>x.trim()).filter(Boolean);
      if(lines.length < 2) continue;
      let timeLineIdx = 0;
      if(!lines[0].includes('-->') && lines[1] && lines[1].includes('-->')) timeLineIdx = 1;
      const tl = lines[timeLineIdx];
      if(!tl || !tl.includes('-->')) continue;
      const [a,b2] = tl.split('-->').map(s=>s.trim());
      const start = parseSrtTime(a);
      const end = parseSrtTime(b2);
      const textLines = lines.slice(timeLineIdx+1);
      const txt = textLines.join(' ')
        .replace(/<[^>]+>/g,'')
        .replace(/\s+/g,' ')
        .trim();
      if(!txt) continue;
      cues.push({start,end,text:txt});
    }
    cues.sort((x,y)=>x.start-y.start);
    return cues;
  }

  function buildChunks(cues, minSec, maxSec){
    const chunks = [];
    let cur = null;

    for(const cue of cues){
      if(!cur){
        cur = {start: cue.start, end: cue.end, text: cue.text};
        continue;
      }
      const nextEnd = Math.max(cur.end, cue.end);
      const nextDur = nextEnd - cur.start;

      if(nextDur <= maxSec){
        cur.end = nextEnd;
        cur.text = (cur.text + " " + cue.text).trim();
      }else{
        chunks.push(cur);
        cur = {start: cue.start, end: cue.end, text: cue.text};
      }
    }
    if(cur) chunks.push(cur);

    const merged = [];
    for(let i=0;i<chunks.length;i++){
      let c = chunks[i];
      while((c.end - c.start) < minSec && i < chunks.length-1){
        const n = chunks[i+1];
        c = {start: c.start, end: n.end, text: (c.text + " " + n.text).trim()};
        i++;
      }
      merged.push(c);
    }
    return merged;
  }

  function styleSuffix(style, custom){
    const map = {
      A: "watercolor fairy-tale illustration, soft paper texture, warm gentle palette, hand-painted feel",
      B: "western storybook illustration, clean linework, textured paint, classic children book look",
      C: "realistic illustration, detailed lighting, natural textures, painterly realism",
      D: "family-friendly animated illustration, bright colors, expressive characters, ORIGINAL design (avoid any existing IP)",
      E: (custom || "")
    };
    return map[style] || map.B;
  }

  function getModeConfig(){
    const mode = el("modeSelect").value;
    if(mode === "k10"){
      return { mode, generateSec: 10, targetSec: 10, stretchFactor: 1.0, label: "Kling 10s（不拉長）" };
    }
    return { mode, generateSec: 5, targetSec: 10, stretchFactor: 2.0, label: "Kling 5s → 拉長10s（省成本）" };
  }

  function getGlobalTail(){
    const style = el("styleSelect").value;
    const custom = el("customStyle").value.trim();
    const ss = styleSuffix(style, custom);
    const suffix = el("globalSuffix").value.trim();
    return [ss, suffix].filter(Boolean).join(", ");
  }


  // ==========================
  // ✅ SFX / Music (Auto + Global + Per-shot)
  // ==========================
  function getGlobalSfx(){
    return (el("globalSfx")?.value || "").trim();
  }
  function getGlobalMusic(){
    return (el("globalMusic")?.value || "").trim();
  }

  function defaultSfxByLevel(level){
    if(level === "tension"){
      return "low rumble impact, subtle growl or tension hit, tense ambience (restrained)";
    }
    if(level === "medium"){
      return "soft movement sound, light contact effect, subtle environmental ambience";
    }
    return "subtle ambient environment sound, light wind, soft cloth/fur movement, natural background atmosphere";
  }

  function defaultMusicByLevel(level){
    if(level === "tension"){
      return "low cinematic tension music, subtle percussion pulse, dramatic atmosphere, restrained";
    }
    if(level === "medium"){
      return "gentle cinematic orchestral background, warm strings, light rhythm, storytelling tone";
    }
    return "soft cinematic background music, emotional storytelling tone, gentle strings and piano, slow tempo";
  }

  function buildSfxPrompt(level){
    const base = defaultSfxByLevel(level);
    const g = getGlobalSfx();
    return [base, g].filter(Boolean).join(", ");
  }

  function buildMusicPrompt(level){
    const base = defaultMusicByLevel(level);
    const g = getGlobalMusic();
    return [base, g].filter(Boolean).join(", ");
  }

  // ==========================
  // ✅ Auto detect + Slider intensity
  // ==========================
  function detectMotionLevel(text){
    const t = (text || "").toLowerCase();

    // tension / conflict
    const tensionWords = [
      "grabbed","caught","roared","angry","suddenly","panic","roar","attack","bit","hurt","fight",
      "chased","swallowed","trapped","screamed","shouted","yelled"
    ];

    // medium / action
    const mediumWords = [
      "ran","running","walked","moved","played","jumped","climbed","slid","slide","pushed","pull",
      "looked","turned","kicked","rolled","fell","fall","stood up","woke","wake","opened","open"
    ];

    if(tensionWords.some(w => t.includes(w))) return "tension";
    if(mediumWords.some(w => t.includes(w))) return "medium";
    return "calm";
  }

  // 每個 level 一個基礎係數（再乘 globalIntensity 與 shotIntensity）
  function baseFactorForLevel(level){
    if(level === "tension") return 1.25;
    if(level === "medium") return 1.00;
    return 0.80; // calm
  }

  // 依強度 factor 產生更細的動作詞（仍保持「微動作」，避免崩）
  function buildMotionTemplate(level, factor){
    // clamp
    factor = Math.max(0, Math.min(2.0, factor));

    const commonHead = [
      "Preserve exact face and identity.",
      "No new characters.",
      "No drastic pose change.",
      "No facial distortion.",
      "",
      "Subtle cinematic motion only:"
    ];

    // 用 factor 決定「是否加入更多微動作」、「鏡頭推進力度」
    const push = (factor < 0.6) ? "very slow push-in camera"
              : (factor < 1.2) ? "slow push-in camera"
              : (factor < 1.6) ? "slow push-in, slightly stronger"
              : "stronger slow push-in (still subtle)";

    const parallax = (factor < 0.6) ? "very slight background parallax"
                  : (factor < 1.2) ? "slight background parallax"
                  : "clearer (but subtle) background parallax";

    const blink = (factor < 0.6) ? "soft eye blink (rare)"
                : "soft eye blink";

    const breathe = (factor < 0.6) ? "gentle breathing movement (minimal)"
                  : "gentle breathing movement";

    const extraHair = (factor >= 1.1) ? "- minimal cloth/hair movement\n" : "";
    const extraBody = (factor >= 1.25) ? "- subtle body weight shift\n" : "";
    const extraLimb = (factor >= 1.45) ? "- tiny limb/paw micro-movement\n" : "";
    const extraTension = (level === "tension" && factor >= 1.2) ? "- subtle muscle tension / slight tighten\n" : "";
    const extraSnap = (level === "tension" && factor >= 1.55) ? "- very small head/eye refocus (no big snap)\n" : "";
    const extraTail = (level === "medium" && factor >= 1.25) ? "- slight tail movement\n" : "";

    let lines = "";
    if(level === "tension"){
      lines =
        `- ${breathe}\n`+
        `- ${blink}\n`+
        `${extraHair}`+
        `${extraTension}`+
        `${extraSnap}`+
        `- ${parallax}\n`+
        `- ${push}\n`;
    }else if(level === "medium"){
      lines =
        `- ${breathe}\n`+
        `- ${blink}\n`+
        `${extraHair}`+
        `${extraBody}`+
        `${extraTail}`+
        `${extraLimb}`+
        `- ${parallax}\n`+
        `- ${push}\n`;
    }else{
      // calm
      lines =
        `- ${breathe}\n`+
        `- ${blink}\n`+
        `${extraHair}`+
        `- ${parallax}\n`+
        `- ${push}\n`;
    }

    const tail = [
      "",
      "Maintain original lighting and composition."
    ];

    return [...commonHead, lines.trimEnd(), ...tail].join("\n");
  }

  function updateTopMeta(){
    const cfg = getModeConfig();
    el("countPill").textContent = `分鏡：${state.shots.length}`;
    el("modePill").textContent = `模式：${cfg.label}`;
    el("durPill").textContent = `Kling：${cfg.generateSec}s → 片段：${cfg.targetSec}s`;
  }

  function buildFinalKlingPrompt(shot){
    const globalTail = getGlobalTail();
    const motion = (shot.motionPrompt || "").trim();
    const scene = (shot.text || "").trim();
    const cam = (shot.cameraPrompt || "").trim();
    const dur = shot.generate_sec;

    return [
      motion,
      scene ? `Scene: ${scene}` : "",
      cam ? `Camera: ${cam}` : "",
      globalTail ? `Style/Quality: ${globalTail}` : "",
      `Duration: ${dur} seconds.`
    ].filter(Boolean).join("

");
  }

  function buildFinalSfxPrompt(shot){
    return (shot.sfxPrompt || "").trim();
  }
  function buildFinalMusicPrompt(shot){
    return (shot.musicPrompt || "").trim();
  }

  function defaultCameraPrompt(){
    return "slow push-in, subtle parallax, steady, no shake";
  }

  function renderCards(){
    const cards = el("cards");
    cards.innerHTML = "";
    const cfg = getModeConfig();

    const globalInt = parseFloat(el("globalIntensity").value || "1") || 1;

    for(let idx=0; idx<state.shots.length; idx++){
      const shot = state.shots[idx];

      // auto motion template if shot not manually edited by user (flag)
      if(!shot.userEditedMotion){
        const level = shot.motionLevel || detectMotionLevel(shot.text);
        shot.motionLevel = level;

        const base = baseFactorForLevel(level);
        const per = (shot.intensity == null) ? 1.0 : shot.intensity;
        const factor = base * globalInt * per;

        shot.motionPrompt = buildMotionTemplate(level, factor);
      }

      // auto SFX/Music if not manually edited
      if(!shot.userEditedSfx){
        const lvlS = shot.motionLevel || detectMotionLevel(shot.text);
        shot.sfxPrompt = buildSfxPrompt(lvlS);
      }
      if(!shot.userEditedMusic){
        const lvlM = shot.motionLevel || detectMotionLevel(shot.text);
        shot.musicPrompt = buildMusicPrompt(lvlM);
      }

      const card = document.createElement("div");
      card.className = "card";

      const thumb = document.createElement("div");
      thumb.className = "thumb";

      const img = document.createElement("img");
      img.src = shot.image.url;
      img.alt = "";
      thumb.appendChild(img);

      const badgeRow = document.createElement("div");
      badgeRow.className = "badgeRow";

      const lvl = (shot.motionLevel || "calm").toUpperCase();
      const badges = [
        `#${pad4(idx+1)}`,
        shot.style,
        `${cfg.generateSec}s`,
        `${cfg.targetSec}s`,
        lvl
      ];
      for(const b of badges){
        const sp = document.createElement("span");
        sp.className = "badge";
        sp.textContent = b;
        badgeRow.appendChild(sp);
      }
      thumb.appendChild(badgeRow);

      const body = document.createElement("div");
      body.className = "cardBody";

      const cap = document.createElement("p");
      cap.className = "capLine";
      cap.textContent = shot.text;
      body.appendChild(cap);

      // ✅ 每段強度滑桿
      const sField = document.createElement("div");
      sField.className = "field";
      const sLabel = document.createElement("div");
      sLabel.className = "miniLabel";
      sLabel.innerHTML = `<span>本段動態強度（乘上 Auto + 全域）</span><span class="smallmuted">level=${shot.motionLevel || "calm"}</span>`;
      const sRow = document.createElement("div");
      sRow.className = "sliderRow";
      const sRange = document.createElement("input");
      sRange.type = "range";
      sRange.min = "0";
      sRange.max = "2";
      sRange.step = "0.05";
      sRange.value = (shot.intensity == null) ? "1" : String(shot.intensity);
      const sVal = document.createElement("div");
      sVal.className = "kv";
      sVal.textContent = (parseFloat(sRange.value)).toFixed(2);

      sRow.appendChild(sRange);
      sRow.appendChild(sVal);
      sField.appendChild(sLabel);
      sField.appendChild(sRow);
      body.appendChild(sField);

      const mini2 = document.createElement("div");
      mini2.className = "mini2";

      // left: motion prompt (editable)
      const left = document.createElement("div");
      const ll = document.createElement("div");
      ll.className = "miniLabel";
      ll.textContent = "動態基底（motion prompt，可手改）";
      const taMotion = document.createElement("textarea");
      taMotion.className = "miniTA";
      taMotion.value = shot.motionPrompt || "";
      left.appendChild(ll);
      left.appendChild(taMotion);

      // right: camera prompt (editable)
      const right = document.createElement("div");
      const rl = document.createElement("div");
      rl.className = "miniLabel";
      rl.textContent = "運鏡（camera / movement）";
      const taCam = document.createElement("textarea");
      taCam.className = "miniTA";
      taCam.value = shot.cameraPrompt || "";
      right.appendChild(rl);
      right.appendChild(taCam);

      mini2.appendChild(left);
      mini2.appendChild(right);
      body.appendChild(mini2);


      // ✅ SFX / Music (editable)
      const mini2b = document.createElement("div");
      mini2b.className = "mini2";
      mini2b.style.marginTop = "10px";

      const sfxBox = document.createElement("div");
      const sfxL = document.createElement("div");
      sfxL.className = "miniLabel";
      sfxL.textContent = "音效（SFX，可手改，貼到 Kling 音效欄）";
      const taSfx = document.createElement("textarea");
      taSfx.className = "miniTA";
      taSfx.value = shot.sfxPrompt || "";
      sfxBox.appendChild(sfxL);
      sfxBox.appendChild(taSfx);

      const musicBox = document.createElement("div");
      const musicL = document.createElement("div");
      musicL.className = "miniLabel";
      musicL.textContent = "配樂（Music，可手改，貼到 Kling 配樂欄）";
      const taMusic = document.createElement("textarea");
      taMusic.className = "miniTA";
      taMusic.value = shot.musicPrompt || "";
      musicBox.appendChild(musicL);
      musicBox.appendChild(taMusic);

      mini2b.appendChild(sfxBox);
      mini2b.appendChild(musicBox);
      body.appendChild(mini2b);

      // final prompt (readonly) + copy button
      const finalWrap = document.createElement("div");
      finalWrap.className = "finalWrap";

      const fl = document.createElement("div");
      fl.className = "miniLabel";
      fl.innerHTML = `<span>最終 Kling Prompt（可直接貼，與 JSON 一致）</span><span class="smallmuted">${shot.generate_sec}s</span>`;

      const taFinal = document.createElement("textarea");
      taFinal.className = "miniTA finalTA";
      taFinal.readOnly = true;
      taFinal.value = buildFinalKlingPrompt(shot);


      // ✅ Final SFX / Music (readonly)
      const taFinalSfx = document.createElement("textarea");
      taFinalSfx.className = "miniTA";
      taFinalSfx.readOnly = true;
      taFinalSfx.style.marginTop = "10px";
      taFinalSfx.value = buildFinalSfxPrompt(shot);

      const taFinalMusic = document.createElement("textarea");
      taFinalMusic.className = "miniTA";
      taFinalMusic.readOnly = true;
      taFinalMusic.style.marginTop = "10px";
      taFinalMusic.value = buildFinalMusicPrompt(shot);

      const copyLine = document.createElement("div");
      copyLine.className = "copyLine";

      const btnCopyFinal = document.createElement("button");
      btnCopyFinal.className = "tinyBtn";
      btnCopyFinal.type = "button";
      btnCopyFinal.textContent = "複製本段 Prompt";
      btnCopyFinal.addEventListener("click", async ()=>{
        try{
          await navigator.clipboard.writeText(taFinal.value);
          btnCopyFinal.textContent = "已複製 ✓";
          setTimeout(()=>btnCopyFinal.textContent="複製本段 Prompt", 900);
        }catch(e){
          alert("複製失敗：瀏覽器權限限制");
        }
      });

      // ✅ 一鍵：回到 Auto（清除手改、用滑桿控制）
      const btnBackAuto = document.createElement("button");
      btnBackAuto.className = "tinyBtn";
      btnBackAuto.type = "button";
      btnBackAuto.textContent = "回到 Auto";
      btnBackAuto.addEventListener("click", ()=>{
        shot.userEditedMotion = false;
        shot.userEditedSfx = false;
        shot.userEditedMusic = false;
        shot.motionLevel = detectMotionLevel(shot.text);
        // 觸發重算
        renderCards();
      });

      copyLine.appendChild(btnBackAuto);
      copyLine.appendChild(btnCopyFinal);

      
      const fl2 = document.createElement("div");
      fl2.className = "miniLabel";
      fl2.innerHTML = `<span>音效（SFX）— 貼到 Kling 音效欄</span><span class="smallmuted">Auto + 全域 + 本段</span>`;

      const fl3 = document.createElement("div");
      fl3.className = "miniLabel";
      fl3.style.marginTop = "8px";
      fl3.innerHTML = `<span>配樂（Music）— 貼到 Kling 配樂欄</span><span class="smallmuted">Auto + 全域 + 本段</span>`;

      const copyLine2 = document.createElement("div");
      copyLine2.className = "copyLine";
      copyLine2.style.marginTop = "8px";

      const btnCopySfx = document.createElement("button");
      btnCopySfx.className = "tinyBtn";
      btnCopySfx.type = "button";
      btnCopySfx.textContent = "複製音效";
      btnCopySfx.addEventListener("click", async ()=>{
        try{
          await navigator.clipboard.writeText(taFinalSfx.value);
          btnCopySfx.textContent = "已複製 ✓";
          setTimeout(()=>btnCopySfx.textContent="複製音效", 900);
        }catch(e){ alert("複製失敗：瀏覽器權限限制"); }
      });

      const btnCopyMusic = document.createElement("button");
      btnCopyMusic.className = "tinyBtn";
      btnCopyMusic.type = "button";
      btnCopyMusic.textContent = "複製配樂";
      btnCopyMusic.addEventListener("click", async ()=>{
        try{
          await navigator.clipboard.writeText(taFinalMusic.value);
          btnCopyMusic.textContent = "已複製 ✓";
          setTimeout(()=>btnCopyMusic.textContent="複製配樂", 900);
        }catch(e){ alert("複製失敗：瀏覽器權限限制"); }
      });

      copyLine2.appendChild(btnCopySfx);
      copyLine2.appendChild(btnCopyMusic);

finalWrap.appendChild(fl);
      finalWrap.appendChild(taFinal);
      finalWrap.appendChild(copyLine);
      finalWrap.appendChild(fl2);
      finalWrap.appendChild(taFinalSfx);
      finalWrap.appendChild(fl3);
      finalWrap.appendChild(taFinalMusic);
      finalWrap.appendChild(copyLine2);
      body.appendChild(finalWrap);

      const info = document.createElement("div");
      info.className = "smallmuted";
      info.style.marginTop = "10px";
      info.textContent = `${shot.image.name} ｜ SRT: ${shot.start.toFixed(2)}–${shot.end.toFixed(2)}`;
      body.appendChild(info);

      function refreshFinal(){
        taFinal.value = buildFinalKlingPrompt(shot);
        taFinalSfx.value = buildFinalSfxPrompt(shot);
        taFinalMusic.value = buildFinalMusicPrompt(shot);
      }

      // slider per shot changes
      sRange.addEventListener("input", ()=>{
        shot.intensity = parseFloat(sRange.value || "1") || 1;
        sVal.textContent = (shot.intensity).toFixed(2);

        // 若還在 auto 模式，重算 motionPrompt
        if(!shot.userEditedMotion){
          const lvl2 = shot.motionLevel || detectMotionLevel(shot.text);
          const base = baseFactorForLevel(lvl2);
          const factor = base * (parseFloat(el("globalIntensity").value || "1") || 1) * shot.intensity;
          shot.motionPrompt = buildMotionTemplate(lvl2, factor);
          taMotion.value = shot.motionPrompt;
        }
        refreshFinal();
      });

      // live sync for motion/camera manual edits
      taMotion.addEventListener("input", ()=>{
        shot.motionPrompt = taMotion.value;
        shot.userEditedMotion = true; // ✅ 手動改了就不再 auto 覆蓋
        refreshFinal();
      });
      taCam.addEventListener("input", ()=>{
        shot.cameraPrompt = taCam.value;
        refreshFinal();
      });

      taSfx.addEventListener("input", ()=>{
        shot.sfxPrompt = taSfx.value;
        shot.userEditedSfx = true;
        refreshFinal();
      });
      taMusic.addEventListener("input", ()=>{
        shot.musicPrompt = taMusic.value;
        shot.userEditedMusic = true;
        refreshFinal();
      });

      card.appendChild(thumb);
      card.appendChild(body);
      cards.appendChild(card);
    }

    updateTopMeta();
    el("copyJsonBtn").disabled = state.shots.length === 0;
    el("downloadJsonBtn").disabled = state.shots.length === 0;
  }

  function buildShots(){
    if(state.images.length === 0){ alert("請先匯入圖片"); return; }
    if(!state.srtText){ alert("請先匯入 SRT"); return; }

    const minSec = Math.max(1, parseInt(el("minSec").value || "10", 10));
    const maxSec = Math.max(minSec, parseInt(el("maxSec").value || String(minSec), 10));

    state.cues = parseSrt(state.srtText);
    state.chunks = buildChunks(state.cues, minSec, maxSec);

    const n = Math.min(state.images.length, state.chunks.length);
    const cfg = getModeConfig();

    const cat = el("catSelect").value;
    const style = el("styleSelect").value;

    state.baseName = state.baseName || safeBaseFromImages(state.images);

    state.shots = [];
    for(let i=0;i<n;i++){
      const img = state.images[i];
      const ch = state.chunks[i];
      const narration = ch.text;

      const lvl = detectMotionLevel(narration);

      state.shots.push({
        id: i+1,
        base: state.baseName,
        category: cat,
        style,
        image: img,
        start: ch.start,
        end: ch.end,
        text: narration,
        mode: cfg.mode,
        generate_sec: cfg.generateSec,
        target_sec: cfg.targetSec,
        stretch_factor: cfg.stretchFactor,

        // ✅ auto level + slider
        motionLevel: lvl,
        intensity: 1.0,
        userEditedMotion: false,

        // ✅ SFX / Music
        userEditedSfx: false,
        userEditedMusic: false,
        sfxPrompt: "",
        musicPrompt: "",

        // placeholders (will be computed in renderCards)
        motionPrompt: "",
        cameraPrompt: defaultCameraPrompt()
      });
    }

    setStatus(`已產生 ${state.shots.length} 段`);
    renderCards();
  }

  function buildJson(){
    const cfg = getModeConfig();
    const base = state.baseName || safeBaseFromImages(state.images);
    const globalTail = getGlobalTail();
    const globalIntensity = parseFloat(el("globalIntensity").value || "1") || 1;

    return {
      meta: {
        base,
        category: el("catSelect").value,
        style: el("styleSelect").value,
        mode: cfg.mode,
        kling_generate_sec: cfg.generateSec,
        target_sec: cfg.targetSec,
        stretch_factor: cfg.stretchFactor,
        mp3_sec: 10,
        min_chunk_sec: parseInt(el("minSec").value || "10", 10),
        max_chunk_sec: parseInt(el("maxSec").value || "10", 10),
        global_suffix: globalTail || null,
        global_sfx: getGlobalSfx() || null,
        global_music: getGlobalMusic() || null,

        // ✅ 新增：強度資訊（不影響你下游，只是備註）
        auto_motion: true,
        global_intensity: globalIntensity,

        created_at: new Date().toISOString()
      },
      shots: state.shots.map(s => ({
        id: s.id,
        image_name: s.image.name,
        srt_start: s.start,
        srt_end: s.end,
        narration: s.text,

        // ✅ 下游用的時間
        generate_sec: s.generate_sec,
        target_sec: s.target_sec,
        stretch_factor: s.stretch_factor,

        // ✅ 附上判斷結果（備註/可回溯）
        motion_level: s.motionLevel,
        per_shot_intensity: s.intensity,

        // ✅ 最重要：最終可貼 prompt
        kling_prompt: buildFinalKlingPrompt(s),
        sfx_prompt: buildFinalSfxPrompt(s),
        music_prompt: buildFinalMusicPrompt(s)
      }))
    };
  }

  async function copyJson(){
    const payload = buildJson();
    await navigator.clipboard.writeText(JSON.stringify(payload, null, 2));
    alert("已複製 JSON");
  }
  function downloadJson(){
    const payload = buildJson();
    const txt = JSON.stringify(payload, null, 2);
    const base = state.baseName || safeBaseFromImages(state.images) || "kling";
    const blob = new Blob([txt], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `${base}_kling.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
  }

  // ===== bindings =====
  el("imgInput").addEventListener("change", (e)=>{
    const files = Array.from(e.target.files || []);
    if(!files.length){
      state.images.forEach(x=>{ try{ URL.revokeObjectURL(x.url);}catch{} });
      state.images = [];
      el("imgInfo").textContent = "尚未選擇圖片";
      return;
    }
    const imgs = files.map(f => ({ name: f.name, url: URL.createObjectURL(f), file: f }));
    imgs.sort(sortByName);

    state.images.forEach(x=>{ try{ URL.revokeObjectURL(x.url);}catch{} });
    state.images = imgs;
    state.baseName = safeBaseFromImages(imgs);

    el("imgInfo").textContent = `已選擇 ${imgs.length} 張（base：${state.baseName || "—"}）`;
    setStatus("已匯入圖片");
  });

  el("srtInput").addEventListener("change", async (e)=>{
    const f = (e.target.files || [])[0];
    if(!f){
      state.srtText = "";
      el("srtInfo").textContent = "尚未選擇 SRT";
      return;
    }
    state.srtText = await f.text();
    el("srtInfo").textContent = `已匯入：${f.name}`;
    setStatus("已匯入 SRT");
  });

  el("styleSelect").addEventListener("change", ()=>{
    el("customStyleWrap").style.display = (el("styleSelect").value === "E") ? "block" : "none";
    if(state.shots.length) renderCards();
  });
  el("customStyle").addEventListener("input", ()=>{
    if(state.shots.length) renderCards();
  });
  el("globalSuffix").addEventListener("input", ()=>{
    if(state.shots.length) renderCards();
  });

  el("globalSfx").addEventListener("input", ()=>{
    if(state.shots.length) renderCards();
  });
  el("globalMusic").addEventListener("input", ()=>{
    if(state.shots.length) renderCards();
  });

  el("modeSelect").addEventListener("change", ()=>{
    updateTopMeta();
    if(state.shots.length){
      const cfg = getModeConfig();
      state.shots.forEach(s=>{
        s.mode = cfg.mode;
        s.generate_sec = cfg.generateSec;
        s.target_sec = cfg.targetSec;
        s.stretch_factor = cfg.stretchFactor;
      });
      renderCards();
    }
  });

  // ✅ 全域強度滑桿
  el("globalIntensity").addEventListener("input", ()=>{
    const v = parseFloat(el("globalIntensity").value || "1") || 1;
    el("globalIntensityVal").textContent = v.toFixed(2);
    if(state.shots.length) renderCards();
  });
  el("globalIntensityVal").textContent = (parseFloat(el("globalIntensity").value||"1")||1).toFixed(2);

  el("buildBtn").addEventListener("click", buildShots);
  el("copyJsonBtn").addEventListener("click", copyJson);
  el("downloadJsonBtn").addEventListener("click", downloadJson);

  el("applyDefaultBtn").addEventListener("click", ()=>{
    if(!state.shots.length){ alert("請先產生分鏡"); return; }
    state.shots.forEach(s=>{
      s.userEditedMotion = false;         // ✅ 回 auto
      s.userEditedSfx = false;
      s.userEditedMusic = false;
      s.motionLevel = detectMotionLevel(s.text);
      s.cameraPrompt = defaultCameraPrompt();
      s.intensity = 1.0;
    });
    renderCards();
    alert("已重置：動態回 Auto + 運鏡重置 + 本段強度=1.0");
  });

  el("clearBtn").addEventListener("click", ()=>{
    state.images.forEach(x=>{ try{URL.revokeObjectURL(x.url)}catch{} });
    state.images = [];
    state.srtText = "";
    state.cues = [];
    state.chunks = [];
    state.shots = [];
    state.baseName = "";

    el("imgInput").value = "";
    el("srtInput").value = "";
    el("imgInfo").textContent = "尚未選擇圖片";
    el("srtInfo").textContent = "尚未選擇 SRT";
    el("cards").innerHTML = "";
    setStatus("尚未產生");
    updateTopMeta();
    el("copyJsonBtn").disabled = true;
    el("downloadJsonBtn").disabled = true;
  });

  // init
  updateTopMeta();
  setStatus("尚未產生");
</script>
</body>
</html>

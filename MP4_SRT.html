<!doctype html>
<html lang="zh-Hant">
<head>
  
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
<meta http-equiv="Pragma" content="no-cache"/>
<meta http-equiv="Expires" content="0"/>
<meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BookWide - Story Kling JSON (OK02 SRT segments)</title>
  <style>


/* ===== Minimal Version Tag ===== */
#versionBadge{
  position: fixed;
  bottom: 6px;
  left: 10px;
  z-index: 9999;
  background: transparent;
  color: #6aa7ff;
  font-size: 11px;
  opacity: .6;
  font-weight: 500;
  letter-spacing: .2px;
}


    
select option{ color:#111; background:#fff; }
:root{
      --bg:#070b14;
      --panel:#0c1426;
      --border:rgba(255,255,255,.08);
      --muted:rgba(255,255,255,.65);
      --text:rgba(255,255,255,.92);
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", Arial, sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 600px at 20% -20%, rgba(85,140,255,.22), transparent 55%),
                  radial-gradient(900px 500px at 90% 10%, rgba(0,255,209,.10), transparent 55%),
                  radial-gradient(900px 500px at 40% 110%, rgba(255,142,0,.10), transparent 55%),
                  var(--bg);
      color:var(--text);
    }
    header{
      padding:18px 18px 8px;
      border-bottom:1px solid var(--border);
      background: linear-gradient(to bottom, rgba(255,255,255,.03), transparent);
    }
    header h1{ margin:0 0 6px; font-size:18px; letter-spacing:.2px; }
    header .sub{ margin:0; font-size:13px; color:var(--muted); line-height:1.4; }

    /* topBar */
    .topBar{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .topLeft{ min-width: 320px; }
    .topLinks{
      display:flex;
      align-items:center;
      gap:10px;
      padding-top:2px;
    }
    .topBtn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      padding:10px 14px;
      border-radius:12px;
      font-weight:800;
      text-decoration:none;
      white-space:nowrap;
      border:1px solid rgba(56,248,208,.35);
      background: linear-gradient(180deg, rgba(56,248,208,.95), rgba(30,198,168,.92));
      color:#000;
      box-shadow:0 8px 20px rgba(0,255,209,.28);
    }
    .topBtn.ghost{
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      border: 1px solid rgba(255,255,255,.16);
      box-shadow:none;
    }
    .topBtn:hover{ filter:brightness(1.03); }
    .topBtn.ghost:hover{ background: rgba(255,255,255,.08); }


    .wrap{
      display:grid;
      grid-template-columns: 410px 1fr;
      gap:16px;
      padding:16px;
      max-width: 1500px;
      margin:0 auto;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.03), transparent 18%),
                  var(--panel);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panel .hd{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .panel .hd .title{ font-size:14px; font-weight:700; margin:0; }
    .panel .hd .hint{ margin:2px 0 0; font-size:12px; color:var(--muted); }
    .panel .bd{ padding:14px; }

    .field{ margin: 0 0 12px; }
    .label{
      font-size:12px;
      color:var(--muted);
      margin:0 0 6px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .label b{ color:rgba(255,255,255,.85); font-weight:700; }

    input[type="file"]{
      width:100%;
      padding:10px;
      border-radius:12px;
      border:1px dashed rgba(255,255,255,.18);
      background: rgba(0,0,0,.20);
      color:var(--muted);
    }
    input[type="text"], input[type="number"], select, textarea{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      color:var(--text);
      outline:none;
    }
    textarea{
      min-height:88px;
      resize:vertical;
      font-family:var(--mono);
      font-size:12px;
      line-height:1.35;
    }
    textarea[readonly]{
      opacity:.95;
      background: rgba(0,0,0,.28);
    }
    .row2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      font-size:12px;
      color:rgba(255,255,255,.78);
      white-space:nowrap;
    }
    .btnrow{ display:flex; flex-wrap:wrap; gap:10px; margin-top:8px; }
    button{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:rgba(255,255,255,.92);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
      letter-spacing:.2px;
    }
    button.primary{
      background: linear-gradient(180deg, rgba(0,255,209,.18), rgba(0,255,209,.08));
      border-color: rgba(0,255,209,.25);
    }
    button.danger{
      background: linear-gradient(180deg, rgba(255,88,88,.18), rgba(255,88,88,.08));
      border-color: rgba(255,88,88,.25);
    }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .note{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      padding:10px 12px;
      border-radius:12px;
      font-size:12px;
      color:rgba(255,255,255,.78);
      line-height:1.4;
    }
    .note b{color:rgba(255,255,255,.90)}
    .smallmuted{ font-size:12px; color:var(--muted); }
    .mono{ font-family:var(--mono); }

    .rightTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:14px;
      border-bottom:1px solid var(--border);
    }
    .rightTop .meta{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      color:var(--muted);
      font-size:12px;
    }
    
.grid{
  display:flex;
  flex-direction:column;
  gap:18px;
  padding:14px;
}
    @media (max-width:1200px){
      .wrap{ grid-template-columns: 1fr; }
      .thumb{ width: 320px; min-width: 320px; }
    }
    @media (max-width:720px){
      .card{ flex-direction:column; }
      .tlRail{ display:none; }
      .thumb{ width:100%; min-width:0; }
    }

    
.card{
  display:flex;
  flex-direction:row;
  align-items:stretch;
  border:1px solid rgba(255,255,255,.10);
  background: linear-gradient(180deg, rgba(255,255,255,.03), transparent 30%),
              rgba(0,0,0,.20);
  border-radius: var(--radius);
  overflow:hidden;
  position:relative;
}
    
.thumb{ position:relative; background:#000; width:380px; min-width:380px; aspect-ratio: 16/9; overflow:hidden; }
    .thumb img{ width:100%; height:100%; object-fit:cover; display:block; filter:saturate(1.05) contrast(1.02); }
    .badgeRow{
      position:absolute;
      left:10px;
      bottom:10px;
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .badge{
      padding:6px 10px;
    }
    .klingToggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.18);
      color:rgba(255,255,255,.92);
      font-size:12px;
      backdrop-filter: blur(6px);
      user-select:none;
      cursor:pointer;
    }
    .klingToggle input{ width:14px; height:14px; margin:0; accent-color:#38f8d0; }
    .klingToggle.on{ border-color: rgba(56,248,208,.45); }
    .klingToggle .t{ font-weight:800; }
    .klingToggle .t.off{ opacity:.75; font-weight:700; }
    .klingHint{ font-size:12px; color:var(--muted); margin-top:8px; }

      border-radius:999px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.16);
      color:rgba(255,255,255,.92);
      font-size:12px;
      backdrop-filter: blur(6px);
    }
    .cardBody{ padding:16px; flex:1; min-width: 420px; }
    
/* ===== Horizontal timeline row ===== */
.tlRail{
  width:64px;
  min-width:64px;
  position:relative;
  background: rgba(0,0,0,.10);
  border-right:1px solid rgba(255,255,255,.06);
  display:flex;
  align-items:flex-start;
  justify-content:center;
  padding-top:14px;
}
.tlLine{
  position:absolute;
  top:0; bottom:0;
  left:50%;
  width:2px;
  transform:translateX(-1px);
  background: linear-gradient(to bottom, rgba(56,248,208,.0), rgba(56,248,208,.55), rgba(56,248,208,.0));
  opacity:.9;
}
.tlDot{
  width:14px; height:14px;
  border-radius:999px;
  background: rgba(56,248,208,.95);
  box-shadow: 0 0 0 4px rgba(56,248,208,.14), 0 10px 30px rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.22);
  position:relative;
  z-index:2;
  margin-top:6px;
}
.tlMeta{
  position:absolute;
  top:8px;
  left:8px;
  right:8px;
  text-align:center;
  font-family:var(--mono);
  font-size:11px;
  color:rgba(255,255,255,.78);
  line-height:1.15;
}
.tlMeta .idx{
  font-weight:800;
  color:rgba(255,255,255,.92);
  font-size:12px;
}
.tlMeta .time{
  margin-top:4px;
  opacity:.85;
  white-space:nowrap;
}

.details{
  margin-top:12px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.14);
  border-radius:14px;
  overflow:hidden;
}
.details > summary{
  list-style:none;
  cursor:pointer;
  padding:10px 12px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  font-size:12px;
  color:rgba(255,255,255,.85);
}
.details > summary::-webkit-details-marker{ display:none; }
.sumRight{
  display:flex;
  align-items:center;
  gap:8px;
  color:rgba(255,255,255,.72);
  font-family:var(--mono);
  font-size:11px;
  white-space:nowrap;
}
.chip{
  padding:4px 8px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.18);
}
.detailsBody{
  padding:12px;
  border-top:1px solid rgba(255,255,255,.08);
}
.capLine{
      font-size:13px;
      color:rgba(255,255,255,.90);
      line-height:1.35;
      margin:0 0 10px;
      min-height: 38px;
      white-space:pre-wrap;
    }
    .mini2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .miniLabel{ font-size:12px; color:var(--muted); margin: 0 0 6px; display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .miniTA{ min-height:78px; font-family:var(--mono); font-size:12px; }

    .finalWrap{ margin-top:10px; }
    .finalTA{ min-height:160px; }
    .copyLine{ display:flex; justify-content:flex-end; gap:10px; margin-top:8px; }
    .tinyBtn{
      padding:8px 10px;
      border-radius:12px;
      font-size:12px;
      font-weight:700;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:rgba(255,255,255,.92);
      cursor:pointer;
    }

    .sliderRow{
      display:flex;
      align-items:center;
      gap:10px;
    }
    input[type="range"]{
      width:100%;
      accent-color: #38f8d0;
    }
    .kv{
      font-family: var(--mono);
      font-size:12px;
      color: rgba(255,255,255,.85);
      white-space:nowrap;
      min-width: 64px;
      text-align:right;
    }
  
/* ===== Kling selection UI (safe append) ===== */
.klingToggle2{
  position:absolute;
  right:10px;
  top:10px;
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:7px 10px;
  border-radius:999px;
  background: rgba(0,0,0,.55);
  border:1px solid rgba(255,255,255,.18);
  color:rgba(255,255,255,.92);
  font-size:12px;
  backdrop-filter: blur(6px);
  user-select:none;
  cursor:pointer;
}
.klingToggle2 input{ width:14px; height:14px; margin:0; accent-color:#38f8d0; }
.klingToggle2.on{ border-color: rgba(56,248,208,.55); box-shadow:0 0 0 3px rgba(56,248,208,.10); }
.klingToggle2 .tag{ font-weight:900; letter-spacing:.2px; }
.klingToggle2 .tag.off{ opacity:.75; font-weight:800; }
.klingCount{
  margin-top:8px;
  font-size:12px;
  color: rgba(255,255,255,.78);
}


/* ===== Visible Narration Preview ===== */
.narrationPreview{
  margin-bottom:12px;
  padding:12px 14px;
  border-radius:10px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.12);
  font-size:14px;
  line-height:1.5;
  color:rgba(255,255,255,.92);
  white-space:pre-wrap;
}
.narrationPreview.empty{
  opacity:.5;
  font-style:italic;
}


    .vGrid{ display:grid; grid-template-columns: 1.3fr 1fr 1fr 1fr; gap:10px; margin-top:8px; }
    .vCell{ display:flex; flex-direction:column; gap:6px; }
    .vMini{ font-size:12px; color:rgba(255,255,255,.7); }
    .miniIn,.miniSel{ width:100%; padding:10px 10px; border-radius:12px; border:1px solid var(--border); background:rgba(255,255,255,.04); color:var(--text); outline:none; }
    .miniSel{ appearance:auto; }
    .vBtnRow{ display:flex; align-items:center; gap:10px; margin-top:10px; }
    .btnSmall{ padding:10px 12px; border-radius:12px; border:1px solid var(--border); background:rgba(255,255,255,.06); color:var(--text); cursor:pointer; }
    .btnSmall.primary{ background:rgba(64,160,255,.2); border-color:rgba(64,160,255,.35); }
    .dirtyTag{ font-size:12px; padding:4px 10px; border-radius:999px; border:1px solid var(--border); color:rgba(255,255,255,.65); }
    .dirtyTag.on{ border-color:rgba(255,196,0,.45); color:rgba(255,196,0,.9); }

  
/* ===== Multi-voice modal ===== */
#multiVoiceModal{position:fixed;inset:0;z-index:99998;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;}
#multiVoiceModal .panel{width:min(920px,92vw);max-height:86vh;overflow:auto;background:#0f1726;border:1px solid rgba(255,255,255,.12);border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.45);padding:14px;}
#multiVoiceModal .row{display:flex;gap:10px;align-items:center;padding:8px 0;border-bottom:1px solid rgba(255,255,255,.08);}
#multiVoiceModal .row:last-child{border-bottom:none;}
#multiVoiceModal .txt{flex:1;padding:10px 12px;border-radius:10px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);color:#fff;font-size:13px;}
#multiVoiceModal .miniSel,#multiVoiceModal .miniInp{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);color:#fff;border-radius:10px;padding:8px 10px;font-size:12px;}
#multiVoiceModal .topbar{display:flex;justify-content:space-between;align-items:center;gap:10px;padding-bottom:10px;}
#multiVoiceModal .topbar .title{font-weight:650;font-size:14px;opacity:.9;}
#multiVoiceModal .btn{border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.06);color:#fff;padding:8px 12px;border-radius:10px;cursor:pointer;font-size:12px;}
#multiVoiceModal .btn.primary{background:rgba(56,189,248,.20);border-color:rgba(56,189,248,.55);}

</style>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>

<body>
<div id="versionBadge">v17 hard-insert-multivoice-btn</div>
<div id="multiVoiceModal"><div class="panel"></div></div>
<div id="roleVoiceModal" style="display:none;">
  <div class="panel">
    <div class="mvHead">
      <div>
        <div class="mvTitle">è§’è‰² â†’ è²éŸ³ï¼ˆå…¨å±€ï¼‰</div>
        <div class="mvSub">åœ¨ SRT æ¯å¥å‰åŠ  <code>[LION]</code> / <code>[MOUSE]</code> / <code>[NARRATOR]</code>ï¼ˆæˆ– <code>LION:</code>ï¼‰ï¼Œå°±æœƒè‡ªå‹•å¥—ç”¨ä¸‹æ–¹å°æ‡‰è²éŸ³ã€‚å–®å¥è‹¥å·²æ‰‹å‹•èª¿è²éŸ³ï¼Œå‰‡ä¸æœƒè¢«è¦†è“‹ã€‚</div>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button class="btn ghost" id="btnRoleAdd">ï¼‹æ–°å¢è§’è‰²</button>
        <button class="btn" id="btnRoleSave">å„²å­˜</button>
        <button class="btn ghost" id="btnRoleClose">é—œé–‰</button>
      </div>
    </div>
    <div class="mvBody" id="roleVoiceBody"></div>
  </div>
</div>


<header>
  <div class="topBar">
    <div class="topLeft">
      <h1>æ•…äº‹å½±ç‰‡ï¼ˆMP4+SRTï¼‰â†’ Kling å‹•ç•«æç¤º JSON</h1>
      <p class="sub">
        æµç¨‹ï¼šåŒ¯å…¥æºé ­ MP4 + SRT â†’ ä¾ SRT è‡ªç„¶åˆ†æ®µï¼ˆå°é½Š OK02ï¼‰â†’ è‡ªå‹•æˆªåœ– â†’ ç”¢å‡ºæ¯æ®µ Kling æç¤º â†’ åŒ¯å‡º JSONã€‚<br/>
        <b>æ–°åŠŸèƒ½ï¼š</b>è‡ªå‹•åˆ¤æ–·å‹•æ…‹å±¤ç´šï¼ˆCalm/Medium/Tensionï¼‰ï¼‹ å…¨åŸŸ/æ¯æ®µã€Œå¼·åº¦æ»‘æ¡¿ã€å¯èª¿ï¼Œæœ€çµ‚ Prompt å³æ™‚æ›´æ–°ä¸¦èˆ‡ JSON ä¸€è‡´ã€‚
      </p>
    </div>

    <div class="topLinks">
      <a class="topBtn" href="https://app.klingai.com/cn/video/new" target="_blank" rel="noopener">ğŸš€ é–‹å•Ÿ Kling</a>
      <a class="topBtn ghost" href="/admin.html" target="_blank" rel="noopener">â†© å› Admin</a>
    </div>
  </div>
</header>

<div class="wrap">
  <!-- LEFT -->
  <section class="panel">
    <div class="hd">
      <div>
        <p class="title">è¨­å®š</p>
        <p class="hint">å…ˆé¸åœ–ç‰‡èˆ‡ SRTï¼Œå†æŒ‰ã€Œç”¢ç”Ÿåˆ†é¡ã€ã€‚</p>
      </div>
      <span class="pill" id="statusPill">å°šæœªç”¢ç”Ÿ</span>
    </div>

    <div class="bd">
      <div class="field">
        <p class="label"><b>1) åŒ¯å…¥æºé ­ MP4</b><span class="smallmuted">å–®æª”ï¼šsource.mp4</span></p>
        <input id="mp4Input" type="file" accept="video/mp4,video/*" />
        <div class="smallmuted" id="mp4Info" style="margin-top:6px;">å°šæœªé¸æ“‡ MP4</div>
        <video id="srcVideo" style="display:none;" preload="metadata" muted playsinline></video>
      </div>

      <div class="field">
        <p class="label"><b>2) åŒ¯å…¥ SRT</b><span class="smallmuted">ä»¥ SRT è‡ªç„¶åˆ†æ®µï¼ˆæ¨è–¦ï¼‰æˆ–èˆŠå›ºå®šç§’æ•¸æ¨¡å¼</span></p>
        <input id="srtInput" type="file" accept=".srt,text/plain" />
        <div class="smallmuted" id="srtInfo" style="margin-top:6px;">å°šæœªé¸æ“‡ SRT</div>
      </div>


      <div class="field" id="roleField">
        <p class="label"><b>2.5) è§’è‰²æ¨™ç¤º / è²éŸ³é–å®š</b><span class="smallmuted">åœ¨æ¯å¥å‰åŠ  <code>[LION]</code> / <code>[MOUSE]</code> / <code>[NARRATOR]</code>ï¼ˆæˆ– <code>LION:</code>ï¼‰</span></p>
        <button class="btn" id="btnRoleVoice">è¨­å®šã€Œè§’è‰²â†’è²éŸ³ã€è¡¨</button>
        <div class="smallmuted" style="margin-top:6px;">
          æœªæ¨™ç¤ºè§’è‰²æ™‚ï¼Œé è¨­ç”¨ <b>NARRATOR</b>ã€‚ä½ åªè¦æ”¹ä¸€è™•è§’è‰²è²éŸ³ï¼Œæ•´å€‹æ•…äº‹åŒè§’è‰²éƒ½æœƒä¸€èµ·å¥—ç”¨ï¼ˆé™¤éä½ å°å–®å¥å·²æ‰‹å‹•èª¿è²éŸ³ï¼‰ã€‚
        </div>
      </div>

      <div class="row2">
        <div class="field">
          <p class="label"><b>æ¯æ®µæœ€çŸ­ç§’æ•¸ï¼ˆminï¼‰</b></p>
          <input id="minSec" type="number" min="1" step="1" value="1" readonly />
        </div>
        <div class="field">
          <p class="label"><b>æ¯æ®µæœ€é•·ç§’æ•¸ï¼ˆmaxï¼‰</b></p>
          <input id="maxSec" type="number" min="1" step="1" value="15" />
        </div>
      </div>

      
<div class="note" style="margin-top:0;margin-bottom:12px;">
  <b>å°é½Šæ¨¡å¼ï¼ˆè¦è·Ÿ OK02 auto_reimage_srt.py åŒç§’æ•¸å°±é¸ã€ŒSRT è‡ªç„¶åˆ†æ®µã€ï¼‰ï¼š</b><br/>
  1) <b>SRT è‡ªç„¶åˆ†æ®µ</b>ï¼šä¾ SRT cue åˆä½µ 1~N å¥ã€é‡åˆ° gap å¤ªå¤§å°±åˆ‡æ®µã€æ¯æ®µ â‰¤ max_secï¼ˆâœ…æœ€æº–ï¼Œå°é½Šä½ å‘½ä»¤åˆ—å°å‡ºçš„ 0~7 / 7~13 / 13~21 ...ï¼‰<br/>
  2) <b>å›ºå®š2+10ç§’</b>ï¼šç¬¬1æ®µ2ç§’ï¼Œå…¶é¤˜æ¯å¼µ10ç§’ï¼ˆèˆŠæ¨¡å¼ï¼Œå®¹æ˜“åˆ‡åˆ°åŠå¥ï¼‰
</div>

<div class="row2">
  <div class="field">
    <p class="label"><b>æ¨¡å¼</b></p>
    <select id="alignMode">
      <option value="srt" selected>SRT è‡ªç„¶åˆ†æ®µï¼ˆæ¨è–¦ / å°é½Š OK02ï¼‰</option>
      <option value="fixed">å›ºå®š 2 ç§’ + å…¶é¤˜ 10 ç§’ï¼ˆèˆŠï¼‰</option>
    </select>
  </div>
  <div class="field">
    <p class="label"><b>max_gapï¼ˆç§’ï¼‰</b><span class="smallmuted">OK02 é è¨­ 1.5</span></p>
    <input id="maxGap" type="number" min="0" step="0.1" value="1.5" />
  </div>
</div>

<div class="row2">
  <div class="field">
    <p class="label"><b>max_sentencesï¼ˆå¥ï¼‰</b><span class="smallmuted">OK02 é è¨­ 3</span></p>
    <input id="maxSent" type="number" min="1" step="1" value="3" />
  </div>
  <div class="field">
    <p class="label"><b>â‰ˆ10 ç§’åˆ¤å®šï¼ˆÂ±ç§’ï¼‰</b><span class="smallmuted">è‡ªå‹•å‹¾é¸ Kling ç”¨</span></p>
    <input id="near10Tol" type="number" min="0" step="0.1" value="0.6" />
  </div>
</div>

<div class="field" style="margin-top:0;margin-bottom:12px;">
  <button class="btn ghost" id="btnPickNear10">åªå‹¾é¸ â‰ˆ10 ç§’æ®µï¼ˆå…¶é¤˜ Stillï¼‰</button>
</div>
<div class="field">
        <p class="label"><b>å‹•æ…‹æ¨¡å¼</b><span class="smallmuted">MP3 ä¸€å¾‹ 10 ç§’ä¸å‹•</span></p>
        <select id="modeSelect">
          <option value="k5_to_10">Kling 5ç§’ç”Ÿæˆ â†’ ffmpeg æ‹‰é•·åˆ° 10ç§’ï¼ˆçœæˆæœ¬ï¼‰</option>
          <option value="k10" selected>Kling 10ç§’ç”Ÿæˆï¼ˆä¸æ‹‰é•·ï¼‰</option>
        </select>
        <div class="note" style="margin-top:8px;">
          <b>5â†’10 æ¨¡å¼ï¼š</b>JSON æœƒè¼¸å‡º <span class="mono">generate_sec=5</span>ã€<span class="mono">target_sec=10</span>ã€<span class="mono">stretch_factor=2.0</span><br/>
          <b>10 ç§’æ¨¡å¼ï¼š</b><span class="mono">generate_sec=10</span>ã€<span class="mono">target_sec=10</span>ã€<span class="mono">stretch_factor=1.0</span>
        </div>
      </div>

      <div class="row2">
        <div class="field">
          <p class="label"><b>é¡åˆ¥</b></p>
          <select id="catSelect">
            <option value="story">æ•…äº‹</option>
            <option value="movie">é›»å½±</option>
            <option value="music">éŸ³æ¨‚</option>
            <option value="news">æ–°è</option>
            <option value="grammar">æ–‡æ³•</option>
          </select>
        </div>
        <div class="field">
          <p class="label"><b>é¢¨æ ¼ï¼ˆA/B/C/D/Eï¼‰</b></p>
          <select id="styleSelect">
            <option value="A">A ç«¥è©±é¢¨</option>
            <option value="B">B æ­ç¾æ•…äº‹æ›¸é¢¨</option>
            <option value="C">C å¯«å¯¦æ’ç•«é¢¨</option>
            <option value="D">D å®¶åº­å‘å‹•ç•«é¢¨ï¼ˆé¿é–‹IPï¼‰</option>
            <option value="E">E è‡ªè¨‚</option>
          </select>
        </div>
      </div>

      <div class="field" id="customStyleWrap" style="display:none;">
        <p class="label"><b>è‡ªè¨‚é¢¨æ ¼ï¼ˆEï¼‰</b><span class="smallmuted">æœƒé™„åŠ åˆ°æ¯æ®µæç¤ºå°¾å·´</span></p>
        <input id="customStyle" type="text" value="original illustration, clean lines, warm color palette, cinematic lighting, high detail, no text" />
      </div>

      <div class="field">
        <p class="label"><b>å…¨åŸŸç•«é¢åŠ æˆï¼ˆæœƒåŠ åˆ°æ¯æ®µæç¤ºå°¾å·´ï¼‰</b></p>
        <textarea id="globalSuffix" placeholder="ä¾‹å¦‚ï¼šcinematic lighting, professional color grading, subtle film grain, high detail, 4k"></textarea>
      </div>

      <div class="field">
        <p class="label"><b>å…¨åŸŸéŸ³æ•ˆï¼ˆSFXï¼‰åŠ æˆï¼ˆæœƒå¯«å…¥æ¯æ®µ JSONï¼‰</b><span class="smallmuted">è²¼åˆ° Kling çš„ã€ŒéŸ³æ•ˆã€æ¬„</span></p>
        <textarea id="globalSfx" placeholder="ä¾‹å¦‚ï¼šsubtle ambient environment sound, light wind, soft cloth movement"></textarea>
        <div class="note" style="margin-top:8px;">
          <b>å»ºè­°ï¼š</b>ä¿æŒ <span class="mono">subtle / soft / gentle</span>ï¼Œé¿å…å¤ªå¼·çƒˆéŸ³æ•ˆå°è‡´ç•«é¢ç¯€å¥äº‚ã€‚
        </div>
      </div>

      <div class="field">
        <p class="label"><b>å…¨åŸŸé…æ¨‚ï¼ˆMusicï¼‰åŠ æˆï¼ˆæœƒå¯«å…¥æ¯æ®µ JSONï¼‰</b><span class="smallmuted">è²¼åˆ° Kling çš„ã€Œé…æ¨‚ã€æ¬„</span></p>
        <textarea id="globalMusic" placeholder="ä¾‹å¦‚ï¼šsoft cinematic background music, gentle strings and piano, slow tempo"></textarea>
        <div class="note" style="margin-top:8px;">
          <b>å»ºè­°ï¼š</b>æ•…äº‹å‹ç”¨æ…¢ç¯€å¥æ•˜äº‹é…æ¨‚ï¼Œé¿å… EDM / å¼·é¼“é»ã€‚
        </div>
      </div>


      <!-- âœ… æ–°å¢ï¼šå…¨åŸŸå¼·åº¦æ»‘æ¡¿ -->
      <div class="field">
        <p class="label">
          <b>å…¨åŸŸå‹•æ…‹å¼·åº¦ï¼ˆAuto + Sliderï¼‰</b>
          <span class="smallmuted">0.0=å¹¾ä¹ä¸å‹•ï½œ1.0=æ­£å¸¸ï½œ2.0=æ›´æ˜é¡¯ï¼ˆä»æ˜¯å¾®å‹•ä½œï¼‰</span>
        </p>
        <div class="sliderRow">
          <input id="globalIntensity" type="range" min="0" max="2" step="0.05" value="1" />
          <div class="kv" id="globalIntensityVal">1.00</div>
        </div>
        <div class="note" style="margin-top:8px;">
          <b>èªªæ˜ï¼š</b>æ¯æ®µå…ˆä¾ narration è‡ªå‹•åˆ¤æ–· Calm/Medium/Tensionï¼Œå†ä¹˜ä¸Šä½ é€™å€‹å…¨åŸŸå¼·åº¦ã€‚
          ä½ ä¹Ÿå¯ä»¥åœ¨æ¯å¼µå¡ç‰‡å†å–®ç¨å¾®èª¿ã€‚
        </div>
      </div>

      <div class="btnrow">
        <button class="primary" id="buildBtn">ç”¢ç”Ÿåˆ†é¡</button>
        <button id="applyDefaultBtn">é‡ç½®å‹•æ…‹åŸºåº•/é‹é¡</button>
        <button id="copyJsonBtn" disabled>è¤‡è£½ JSON</button>
        <button class="primary" id="downloadJsonBtn" disabled>ä¸‹è¼‰ JSON</button>
        <button class="primary" id="exportOk2ZipBtn" disabled>åŒ¯å‡º OK2 å¥—ä»¶ï¼ˆZIPï¼šåªæ›´æ–°è®Šå‹•æ®µï¼‰</button>
        <button class="danger" id="clearBtn">æ¸…ç©º</button>
      
      <div id="klingTools" class="field" style="margin-top:12px;">
        <p class="label"><b>çœæˆæœ¬ï¼šåªè®“å°‘æ•¸æ®µç”¨ Kling</b><span class="smallmuted">å‹¾é¸å¾Œï¼ŒJSON æœƒæ¨™è¨˜ use_kling</span></p>
        <div class="btnrow" style="margin-top:0;">
          <button type="button" id="selectNoneBtn">å…¨éƒ¨å–æ¶ˆ</button>
          <button type="button" id="selectAllBtn">å…¨éƒ¨å‹¾é¸</button>
          <button type="button" id="selectKey6Btn">å¥—ç”¨å»ºè­°6æ®µ</button>
          <button type="button" id="selectKey4Btn">å¥—ç”¨æ¥µçœ4æ®µ</button>
        </div>
        <div class="klingHint">å»ºè­°6æ®µï¼š0005/0006/0018/0019/0023/0025ï¼ˆä¾ç›®å‰åœ–ç‰‡é †åºï¼›è‹¥æ®µæ•¸ä¸è¶³æœƒè‡ªå‹•å¿½ç•¥ï¼‰ã€‚</div>
        <div class="klingCount" id="klingCount">Kling å·²å‹¾é¸ï¼š0</div>
        <div class="btnrow" style="margin-top:10px;">
          <button type="button" id="filterAllBtn" onclick="setViewFilter('all')">é¡¯ç¤ºå…¨éƒ¨</button>
          <button type="button" id="filterKlingBtn" onclick="setViewFilter('kling')">åªé¡¯ç¤º Kling</button>
          <button type="button" id="filterStillBtn" onclick="setViewFilter('still')">åªé¡¯ç¤º Still</button>
        </div>
        <div class="klingHint" id="filterHint">ç›®å‰é¡¯ç¤ºï¼šå…¨éƒ¨</div>
      </div>

</div>

      <div class="note" style="margin-top:12px;">
        <b>å‘½åè¦å‰‡ï¼ˆä½ è¦è·Ÿåœ–ç‰‡åŒåï¼‰ï¼š</b><br/>
        Kling å½±ç‰‡è«‹æ”¾ï¼š<span class="mono">motion_raw\BASE\BASE_0001.mp4</span>ï¼ˆèˆ‡åœ–ç‰‡åŒåï¼Œåªå·®å‰¯æª”åï¼‰
      </div>
    </div>
  </section>

  <!-- RIGHT -->
  <section class="panel">
    <div class="rightTop">
      <div>
        <div style="font-weight:800; font-size:14px;">åˆ†é¡æ¸…å–®</div>
        <div class="smallmuted">æ¯æ®µè‡ªå‹•åˆ¤æ–·å‹•æ…‹å±¤ç´š + å¼·åº¦æ»‘æ¡¿ï¼ˆå…¨åŸŸ/æ¯æ®µï¼‰å¯èª¿ã€‚æœ€çµ‚ Prompt èˆ‡ JSON ä¸€è‡´ã€‚</div>
      </div>
      <div class="meta">
        <span class="pill" id="countPill">åˆ†é¡ï¼š0</span>
        <span class="pill" id="modePill">æ¨¡å¼ï¼šâ€”</span>
        <span class="pill" id="durPill">Klingï¼šâ€”</span>
      </div>
    </div>
    <div class="grid" id="cards"></div>
  </section>
</div>

<script>
console.log('MP4_SRT_VERSION:', 'v20 role-voice-fix+shot-image');

  const state = {
    video: null, // {name, url, file, duration, width, height}
    images: [], // (auto frames) keep for legacy: {name, url}

    srtText: "",
    cues: [],
    chunks: [],
    shots: [],
    baseName: "",
    viewFilter: "all"
  };

  const el = (id)=>document.getElementById(id);
  const pad4 = (n)=>String(n).padStart(4,'0');


  function escapeHtml(str){
    return String(str ?? '')
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;')
      .replace(/"/g,'&quot;')
      .replace(/'/g,'&#39;');
  }

  function sortByName(a,b){
    return a.name.localeCompare(b.name, undefined, {numeric:true, sensitivity:'base'});
  }
  function safeBaseFromImages(images){
    if(!images.length) return "";
    const n = images[0].name;
    const m = n.match(/^(.*)_\d{4}\.(jpg|jpeg|png|webp)$/i);
    if(m) return m[1];
    return n.replace(/\.[^.]+$/,'');
  }
  function setStatus(text){ el("statusPill").textContent = text; }

  function parseSrtTime(t){
    const m = t.trim().match(/(\d+):(\d+):(\d+)[,\.](\d+)/);
    if(!m) return 0;
    const hh = parseInt(m[1],10), mm=parseInt(m[2],10), ss=parseInt(m[3],10), ms=parseInt(m[4],10);
    return hh*3600 + mm*60 + ss + ms/1000;
  }
  function parseSrt(text){
    const blocks = text.replace(/\r/g,'').trim().split(/\n\s*\n/);
    const cues = [];
    for(const b of blocks){
      const lines = b.split('\n').map(x=>x.trim()).filter(Boolean);
      if(lines.length < 2) continue;
      let timeLineIdx = 0;
      if(!lines[0].includes('-->') && lines[1] && lines[1].includes('-->')) timeLineIdx = 1;
      const tl = lines[timeLineIdx];
      if(!tl || !tl.includes('-->')) continue;
      const [a,b2] = tl.split('-->').map(s=>s.trim());
      const start = parseSrtTime(a);
      const end = parseSrtTime(b2);
      const textLines = lines.slice(timeLineIdx+1);
      const txt = textLines.join(' ')
        .replace(/<[^>]+>/g,'')
        .replace(/\s+/g,' ')
        .trim();
      if(!txt) continue;
      cues.push({start,end,text:txt});
    }
    cues.sort((x,y)=>x.start-y.start);
    return cues;
  }

  function buildChunks(cues, minSec, maxSec){
    const chunks = [];
    let cur = null;

    for(const cue of cues){
      if(!cur){
        cur = {start: cue.start, end: cue.end, text: cue.text};
        continue;
      }
      const nextEnd = Math.max(cur.end, cue.end);
      const nextDur = nextEnd - cur.start;

      if(nextDur <= maxSec){
        cur.end = nextEnd;
        cur.text = (cur.text + " " + cue.text).trim();
      }else{
        chunks.push(cur);
        cur = {start: cue.start, end: cue.end, text: cue.text};
      }
    }
    if(cur) chunks.push(cur);

    const merged = [];
    for(let i=0;i<chunks.length;i++){
      let c = chunks[i];
      while((c.end - c.start) < minSec && i < chunks.length-1){
        const n = chunks[i+1];
        c = {start: c.start, end: n.end, text: (c.text + " " + n.text).trim()};
        i++;
      }
      merged.push(c);
    }
    return merged;
  }

  // âœ… å›ºå®šä»¥ã€Œåœ–ç‰‡æ¯å¼µå›ºå®šç§’æ•¸ã€å°é½Šå­—å¹•ï¼ˆæ®µæ•¸ = åœ–ç‰‡æ•¸ï¼‰
  function buildChunksByImages(cues, imageCount, firstSec, restSec){
    const chunks = [];
    let t = 0;
    for(let i=0;i<imageCount;i++){
      const dur = (i===0) ? firstSec : restSec;
      const start = t;
      const end = t + dur;
      t = end;

      const texts = [];
      for(const cue of cues){
        // overlap rule: cue intersects [start,end)
        if(cue.start >= start && cue.start < end){
          texts.push(cue.text);
        }
      }
      const unique = Array.from(new Set(texts.map(t=>String(t||"").replace(/\s+/g," ").trim()).filter(Boolean)));
      const txt = unique.join(" ");
      chunks.push({start, end, text: txt});
    }
    return chunks;
  }


  // âœ… OK02 auto_reimage_srt.py åŒæ¬¾ï¼šSRT è‡ªç„¶åˆ†æ®µï¼ˆmax_sec / max_sentences / max_gapï¼‰
  // cues: [{start,end,text}]
  function buildSegmentsLikeOK02(cues, maxSec, maxSentences, maxGap){
    const segs = [];
    let i = 0;
    const n = cues.length;
    while(i < n){
      let s0 = cues[i].start;
      let e0 = cues[i].end;
      let texts = [cues[i].text];
      let count = 1;
      let j = i + 1;

      while(j < n && count < maxSentences){
        const gap = cues[j].start - e0;
        const candEnd = cues[j].end;
        if(gap > maxGap) break;
        if((candEnd - s0) <= (maxSec + 1e-6)){
          e0 = candEnd;
          texts.push(cues[j].text);
          count += 1;
          j += 1;
        }else{
          break;
        }
      }

      const segText = texts.map(t=>String(t||"").trim()).filter(Boolean).join(" ").trim() || "A short moment in the story.";
      segs.push({start:s0, end:e0, text:segText});
      i = j;
    }
    return segs;
  }

  function durOf(x){ return Math.max(0, (x.end||0) - (x.start||0)); }

  function styleSuffix(style, custom){
    const map = {
      A: "watercolor fairy-tale illustration, soft paper texture, warm gentle palette, hand-painted feel",
      B: "western storybook illustration, clean linework, textured paint, classic children book look",
      C: "realistic illustration, detailed lighting, natural textures, painterly realism",
      D: "family-friendly animated illustration, bright colors, expressive characters, ORIGINAL design (avoid any existing IP)",
      E: (custom || "")
    };
    return map[style] || map.B;
  }

  function getModeConfig(){
    const mode = el("modeSelect").value;
    if(mode === "k10"){
      return { mode, generateSec: 10, targetSec: 10, stretchFactor: 1.0, label: "Kling 10sï¼ˆä¸æ‹‰é•·ï¼‰" };
    }
    return { mode, generateSec: 5, targetSec: 10, stretchFactor: 2.0, label: "Kling 5s â†’ æ‹‰é•·10sï¼ˆçœæˆæœ¬ï¼‰" };
  }

  function getGlobalTail(){
    const style = el("styleSelect").value;
    const custom = el("customStyle").value.trim();
    const ss = styleSuffix(style, custom);
    const suffix = el("globalSuffix").value.trim();
    return [ss, suffix].filter(Boolean).join(", ");
  }


  // ==========================
  // âœ… SFX / Music (Auto + Global + Per-shot)
  // ==========================
  function getGlobalSfx(){
    return (el("globalSfx")?.value || "").trim();
  }
  function getGlobalMusic(){
    return (el("globalMusic")?.value || "").trim();
  }

  function defaultSfxByLevel(level){
    if(level === "tension"){
      return "low rumble impact, subtle growl or tension hit, tense ambience (restrained)";
    }
    if(level === "medium"){
      return "soft movement sound, light contact effect, subtle environmental ambience";
    }
    return "subtle ambient environment sound, light wind, soft cloth/fur movement, natural background atmosphere";
  }

  function defaultMusicByLevel(level){
    if(level === "tension"){
      return "low cinematic tension music, subtle percussion pulse, dramatic atmosphere, restrained";
    }
    if(level === "medium"){
      return "gentle cinematic orchestral background, warm strings, light rhythm, storytelling tone";
    }
    return "soft cinematic background music, emotional storytelling tone, gentle strings and piano, slow tempo";
  }

  function buildSfxPrompt(level){
    const base = defaultSfxByLevel(level);
    const g = getGlobalSfx();
    return [base, g].filter(Boolean).join(", ");
  }

  function buildMusicPrompt(level){
    const base = defaultMusicByLevel(level);
    const g = getGlobalMusic();
    return [base, g].filter(Boolean).join(", ");
  }

  // ==========================
  // âœ… Auto detect + Slider intensity
  // ==========================
  function detectMotionLevel(text){
    const t = (text || "").toLowerCase();

    // tension / conflict
    const tensionWords = [
      "grabbed","caught","roared","angry","suddenly","panic","roar","attack","bit","hurt","fight",
      "chased","swallowed","trapped","screamed","shouted","yelled"
    ];

    // medium / action
    const mediumWords = [
      "ran","running","walked","moved","played","jumped","climbed","slid","slide","pushed","pull",
      "looked","turned","kicked","rolled","fell","fall","stood up","woke","wake","opened","open"
    ];

    if(tensionWords.some(w => t.includes(w))) return "tension";
    if(mediumWords.some(w => t.includes(w))) return "medium";
    return "calm";
  }

  // æ¯å€‹ level ä¸€å€‹åŸºç¤ä¿‚æ•¸ï¼ˆå†ä¹˜ globalIntensity èˆ‡ shotIntensityï¼‰
  function baseFactorForLevel(level){
    if(level === "tension") return 1.25;
    if(level === "medium") return 1.00;
    return 0.80; // calm
  }

  // ä¾å¼·åº¦ factor ç”¢ç”Ÿæ›´ç´°çš„å‹•ä½œè©ï¼ˆä»ä¿æŒã€Œå¾®å‹•ä½œã€ï¼Œé¿å…å´©ï¼‰
  function buildMotionTemplate(level, factor){
    // clamp
    factor = Math.max(0, Math.min(2.0, factor));

    const commonHead = [
      "Preserve exact face and identity.",
      "No new characters.",
      "No drastic pose change.",
      "No facial distortion.",
      "",
      "Subtle cinematic motion only:"
    ];

    // ç”¨ factor æ±ºå®šã€Œæ˜¯å¦åŠ å…¥æ›´å¤šå¾®å‹•ä½œã€ã€ã€Œé¡é ­æ¨é€²åŠ›åº¦ã€
    const push = (factor < 0.6) ? "very slow push-in camera"
              : (factor < 1.2) ? "slow push-in camera"
              : (factor < 1.6) ? "slow push-in, slightly stronger"
              : "stronger slow push-in (still subtle)";

    const parallax = (factor < 0.6) ? "very slight background parallax"
                  : (factor < 1.2) ? "slight background parallax"
                  : "clearer (but subtle) background parallax";

    const blink = (factor < 0.6) ? "soft eye blink (rare)"
                : "soft eye blink";

    const breathe = (factor < 0.6) ? "gentle breathing movement (minimal)"
                  : "gentle breathing movement";

    const extraHair = (factor >= 1.1) ? "- minimal cloth/hair movement\n" : "";
    const extraBody = (factor >= 1.25) ? "- subtle body weight shift\n" : "";
    const extraLimb = (factor >= 1.45) ? "- tiny limb/paw micro-movement\n" : "";
    const extraTension = (level === "tension" && factor >= 1.2) ? "- subtle muscle tension / slight tighten\n" : "";
    const extraSnap = (level === "tension" && factor >= 1.55) ? "- very small head/eye refocus (no big snap)\n" : "";
    const extraTail = (level === "medium" && factor >= 1.25) ? "- slight tail movement\n" : "";

    let lines = "";
    if(level === "tension"){
      lines =
        `- ${breathe}\n`+
        `- ${blink}\n`+
        `${extraHair}`+
        `${extraTension}`+
        `${extraSnap}`+
        `- ${parallax}\n`+
        `- ${push}\n`;
    }else if(level === "medium"){
      lines =
        `- ${breathe}\n`+
        `- ${blink}\n`+
        `${extraHair}`+
        `${extraBody}`+
        `${extraTail}`+
        `${extraLimb}`+
        `- ${parallax}\n`+
        `- ${push}\n`;
    }else{
      // calm
      lines =
        `- ${breathe}\n`+
        `- ${blink}\n`+
        `${extraHair}`+
        `- ${parallax}\n`+
        `- ${push}\n`;
    }

    const tail = [
      "",
      "Maintain original lighting and composition."
    ];

    return [...commonHead, lines.trimEnd(), ...tail].join("\n");
  }

  function updateKlingCount(){
    const n = state.shots.filter(s=>!!s.use_kling).length;
    const kc = document.getElementById('klingCount');
    if(kc) kc.textContent = `Kling å·²å‹¾é¸ï¼š${n}`;
  }
  function updateFilterHint(){
    const fh = document.getElementById('filterHint');
    if(!fh) return;
    const vf = state.viewFilter || 'all';
    const label = vf==='kling' ? 'åªé¡¯ç¤º Kling' : (vf==='still' ? 'åªé¡¯ç¤º Still' : 'å…¨éƒ¨');
    // visible count uses current filter
    let visible = 0;
    for(const s of state.shots){
      if(vf==='kling' && !s.use_kling) continue;
      if(vf==='still' && s.use_kling) continue;
      visible++;
    }
    fh.textContent = `ç›®å‰é¡¯ç¤ºï¼š${label}ï¼ˆ${visible} æ®µï¼‰`;
  }

  function setViewFilter(v){
    state.viewFilter = v || "all";
    // re-render to apply filter reliably
    if(state.shots.length) renderCards();
    updateFilterHint();
  }

  function setAllKling(val){
    if(!state.shots.length) return;
    state.shots.forEach(s=>{ s.use_kling = !!val; });
    if(state.shots.length) renderCards();
  }

  // map recommended ids to current shots by id (1-based)
  function applyRecommended(list){
    if(!state.shots.length) return;
    const set = new Set(list.map(x=>parseInt(x,10)));
    state.shots.forEach(s=>{ s.use_kling = set.has(s.id); });
    renderCards();
  }

  function updateTopMeta(){
    const cfg = getModeConfig();
    el("countPill").textContent = `åˆ†é¡ï¼š${state.shots.length}`;
    el("modePill").textContent = `æ¨¡å¼ï¼š${cfg.label}`;
    el("durPill").textContent = `Klingï¼š${cfg.generateSec}s â†’ ç‰‡æ®µï¼š${cfg.targetSec}s`;
  }

  function buildFinalKlingPrompt(shot){
    const globalTail = getGlobalTail();
    const motion = (shot.motionPrompt || "").trim();
    const scene = (shot.text || "").trim();
    const cam = (shot.cameraPrompt || "").trim();
    const dur = shot.generate_sec;

    return [
      motion,
      scene ? `Scene: ${scene}` : "",
      cam ? `Camera: ${cam}` : "",
      globalTail ? `Style/Quality: ${globalTail}` : "",
      `Duration: ${dur} seconds.`
    ].filter(Boolean).join("\n\n");
  }

  function buildFinalSfxPrompt(shot){
    return (shot.sfxPrompt || "").trim();
  }
  function buildFinalMusicPrompt(shot){
    return (shot.musicPrompt || "").trim();
  }

  function defaultCameraPrompt(){
    return "slow push-in, subtle parallax, steady, no shake";
  }

  function renderCards(){
    const cards = el("cards");
    cards.innerHTML = "";
    const cfg = getModeConfig();

    const globalInt = parseFloat(el("globalIntensity").value || "1") || 1;

    const vf = state.viewFilter || "all";
    for(let idx=0; idx<state.shots.length; idx++){
      const shot = state.shots[idx];
      if(!shot.role) shot.role = "narration";
      if(!shot.role) shot.role = "narration";
      if(!shot.role) shot.role = "narration";
      if(vf === "kling" && !shot.use_kling) continue;
      if(vf === "still" && shot.use_kling) continue;

      // auto motion template if shot not manually edited by user (flag)
      if(!shot.userEditedMotion){
        const level = shot.motionLevel || detectMotionLevel(shot.text);
        shot.motionLevel = level;

        const base = baseFactorForLevel(level);
        const per = (shot.intensity == null) ? 1.0 : shot.intensity;
        const factor = base * globalInt * per;

        shot.motionPrompt = buildMotionTemplate(level, factor);
      }

      // auto SFX/Music if not manually edited
      if(!shot.userEditedSfx){
        const lvlS = shot.motionLevel || detectMotionLevel(shot.text);
        shot.sfxPrompt = buildSfxPrompt(lvlS);
      }
      if(!shot.userEditedMusic){
        const lvlM = shot.motionLevel || detectMotionLevel(shot.text);
        shot.musicPrompt = buildMusicPrompt(lvlM);
      }

      const card = document.createElement("div");
      card.className = "card";
      card.dataset.cardSegid = shot.id;

      // timeline rail
      const tlRail = document.createElement("div");
      tlRail.className = "tlRail";
      const tlLine = document.createElement("div");
      tlLine.className = "tlLine";
      const tlMeta = document.createElement("div");
      tlMeta.className = "tlMeta";
      const tStart = shot.start.toFixed(2);
      const tEnd = shot.end.toFixed(2);
      tlMeta.innerHTML = `<div class="idx">#${pad4(idx+1)}</div><div class="time">${tStart}â€“${tEnd}</div>`;
      const tlDot = document.createElement("div");
      tlDot.className = "tlDot";
      tlRail.appendChild(tlLine);
      tlRail.appendChild(tlMeta);
      tlRail.appendChild(tlDot);

      const thumb = document.createElement("div");
      thumb.className = "thumb";

      const img = document.createElement("img");
      const _imgUrl = (shot.image && shot.image.url) ? shot.image.url : (shot.image_url || shot.url || '');
      if(_imgUrl) img.src = _imgUrl;
      img.alt = "";
      thumb.appendChild(img);

      const badgeRow = document.createElement("div");
      badgeRow.className = "badgeRow";

      const lvl = (shot.motionLevel || "calm").toUpperCase();
      const segDur = Math.max(0, (shot.end - shot.start));
const badges = [
  `#${pad4(idx+1)}`,
  shot.style,
  `è§’è‰²:${(shot.role||'NARRATOR')}`,
  `${segDur.toFixed(2)}s`,
  lvl
];
      for(const b of badges){
        const sp = document.createElement("span");
        sp.className = "badge";
        sp.textContent = b;
        badgeRow.appendChild(sp);
      }

      // âœ… Kling å‹•æ…‹æ¨™è¨˜ï¼ˆçœæˆæœ¬ï¼šåªå‹¾å°‘æ•¸æ®µé€ Klingï¼‰
      const kt = document.createElement("label");
      const on = !!shot.use_kling;
      kt.className = "klingToggle" + (on ? " on" : "");
      kt.innerHTML = `<input type="checkbox"${on ? " checked" : ""} /> <span class="t ${on ? "" : "off"}">${on ? "Kling" : "Still"}</span>`;
      const kcb = kt.querySelector("input");
      kcb.addEventListener("change", ()=>{
        shot.use_kling = !!kcb.checked;
        // update label + border instantly
        const t = kt.querySelector(".t");
        if(shot.use_kling){
          kt.classList.add("on");
          t.textContent = "Kling";
          t.classList.remove("off");
        }else{
          kt.classList.remove("on");
          t.textContent = "Still";
          t.classList.add("off");
        }
        updateKlingCount();
        updateFilterHint();
        // å¦‚æœç›®å‰åœ¨ç¯©é¸æ¨¡å¼ï¼Œåˆ‡æ›å¾Œç«‹å³å¥—ç”¨
        if(state.viewFilter !== 'all') renderCards();
      });
      badgeRow.appendChild(kt);

      thumb.appendChild(badgeRow);

      const body = document.createElement("div");
      body.className = "cardBody";
      const previewDiv = document.createElement("div");
      const _txt = (shot.text || "").trim();
      previewDiv.className = "narrationPreview" + (_txt ? "" : " empty");
      previewDiv.textContent = _txt || "ï¼ˆæ­¤æ®µæ²’æœ‰å­—å¹•ï¼‰";
      body.appendChild(previewDiv);

      // âœ… æ¯æ®µèªéŸ³é¢æ¿ï¼ˆvoice / rate / pitch / volume + è©¦è½ï¼‰
      if(!shot.voiceCfg){
        shot.voiceCfg = { voice: "en-US-JennyNeural", rate: "+0%", pitch: "+0Hz", volume: "+0%" };
      }
      const vField = document.createElement("div");
      vField.className = "field";
      const vLabel = document.createElement("div");
      vLabel.className = "miniLabel";
      vLabel.innerHTML = `<span>èªéŸ³ï¼ˆæœ¬æ®µï¼‰</span><span class="smallmuted">è©¦è½ / åŒ¯å‡º mp3</span>`;
      const vGrid = document.createElement("div");
      vGrid.className = "vGrid";

      const mkIn = (lab, val, ph) => {
        const w = document.createElement("div");
        w.className = "vCell";
        const l = document.createElement("div");
        l.className = "vMini";
        l.textContent = lab;
        const inp = document.createElement("input");
        inp.className = "miniIn";
        inp.value = val || "";
        if(ph) inp.placeholder = ph;
        w.appendChild(l); w.appendChild(inp);
        return {w, inp};
      };

      // voice select + custom
      const voiceWrap = document.createElement("div");
      voiceWrap.className = "vCell";
      const voiceLab = document.createElement("div");
      voiceLab.className = "vMini";
      voiceLab.textContent = "voice";
      const voiceSel = document.createElement("select");
      voiceSel.className = "miniSel";
      const voices = [
  // English (Female)
  "en-US-JennyNeural",
  "en-US-AriaNeural",
  "en-US-MichelleNeural",
  "en-US-SaraNeural",
        "en-US-AnaNeural",

  // English (Male)
  "en-US-GuyNeural",
  "en-US-DavisNeural",
  "en-US-BrandonNeural",
  "en-US-ChristopherNeural",
  "en-US-EricNeural",

  // Chinese / Japanese
  "zh-TW-HsiaoChenNeural",
  "zh-TW-YunJheNeural",
  "ja-JP-NanamiNeural",
  "ja-JP-KeitaNeural"
];
      for(const v of voices){
        const opt = document.createElement("option");
        opt.value = v; opt.textContent = v;
        voiceSel.appendChild(opt);
      }
      const customOpt = document.createElement("option");
      customOpt.value = "__custom__";
      customOpt.textContent = "ï¼ˆè‡ªè¨‚ï¼‰";
      voiceSel.appendChild(customOpt);

      const voiceCustom = document.createElement("input");
      voiceCustom.className = "miniIn";
      voiceCustom.placeholder = "è¼¸å…¥è‡ªè¨‚ voice åç¨±";
      voiceCustom.style.display = "none";

      if(voices.includes(shot.voiceCfg.voice)){
        voiceSel.value = shot.voiceCfg.voice;
      }else{
        voiceSel.value = "__custom__";
        voiceCustom.style.display = "block";
        voiceCustom.value = shot.voiceCfg.voice || "";
      }

      voiceSel.addEventListener("change", ()=>{
        if(voiceSel.value === "__custom__"){
          voiceCustom.style.display = "block";
          shot.voiceCfg.voice = voiceCustom.value || "";
        }else{
          voiceCustom.style.display = "none";
          shot.voiceCfg.voice = voiceSel.value;
        }
        markVoiceDirty(shot);
      });
      voiceCustom.addEventListener("input", ()=>{
        if(voiceSel.value === "__custom__"){
          shot.voiceCfg.voice = voiceCustom.value || "";
          markVoiceDirty(shot);
        }
      });

      voiceWrap.appendChild(voiceLab);
      voiceWrap.appendChild(voiceSel);
      voiceWrap.appendChild(voiceCustom);

      const rate = mkIn("rate", shot.voiceCfg.rate, "+10% / -10%");
      const pitch = mkIn("pitch", shot.voiceCfg.pitch, "+40Hz / -40Hz");
      const volume = mkIn("volume", shot.voiceCfg.volume, "+5% / -5%");

      rate.inp.addEventListener("input", ()=>{ shot.voiceCfg.rate = rate.inp.value || "+0%"; markVoiceDirty(shot); });
      pitch.inp.addEventListener("input", ()=>{ shot.voiceCfg.pitch = pitch.inp.value || "+0Hz"; markVoiceDirty(shot); });
      volume.inp.addEventListener("input", ()=>{ shot.voiceCfg.volume = volume.inp.value || "+0%"; markVoiceDirty(shot); });

      const vBtnRow = document.createElement("div");
      vBtnRow.className = "vBtnRow";
      const btnPrev = document.createElement("button");
      btnPrev.className = "btnSmall primary";
      btnPrev.textContent = "â–¶ è©¦è½æœ¬æ®µ";
      btnPrev.addEventListener("click", async ()=>{
        btnPrev.disabled = true;
        btnPrev.textContent = "ç”¢ç”Ÿä¸­...";
        try{
          await previewTTSForShot(shot);
        }catch(e){
          alert(String(e));
          console.error(e);
        }finally{
          btnPrev.disabled = false;
          btnPrev.textContent = "â–¶ è©¦è½æœ¬æ®µ";
        }
      });

      const dirty = document.createElement("span");
      dirty.className = "dirtyTag" + (shot.voiceDirty ? " on" : "");
      dirty.dataset.segid = shot.id;
      dirty.textContent = shot.voiceDirty ? "å·²æ”¹" : "æœªæ”¹";

      vBtnRow.appendChild(btnPrev);
      // âœ… å¥å…§å¤šè²ï¼ˆåŒæ®µå¤šå¥ä¸åŒè²éŸ³ï¼Œæ®µæ•¸ä¸å¢åŠ ï¼‰
      const btnMultiVoice = document.createElement("button");
      btnMultiVoice.className = "btnSmall";
      btnMultiVoice.textContent = (shot.multiVoiceEnabled ? "å¥å…§å¤šè²âœ…" : "å¥å…§å¤šè²");
      btnMultiVoice.title = "åŒä¸€æ®µå…§æ¯ä¸€å¥å¯è¨­å®šä¸åŒ voiceï¼›åŒ¯å‡ºä» 1 å€‹ mp3ï¼ˆæ®µæ•¸ç¶­æŒä¸è®Šï¼‰";
      btnMultiVoice.addEventListener("click", ()=>{ openMultiVoiceModal(shot); btnMultiVoice.textContent = (shot.multiVoiceEnabled ? "å¥å…§å¤šè²âœ…" : "å¥å…§å¤šè²"); });
      vBtnRow.appendChild(btnMultiVoice);
      vBtnRow.appendChild(dirty);

      vGrid.appendChild(voiceWrap);
      vGrid.appendChild(rate.w);
      vGrid.appendChild(pitch.w);
      vGrid.appendChild(volume.w);

      vField.appendChild(vLabel);
      vField.appendChild(vGrid);
      vField.appendChild(vBtnRow);
      body.appendChild(vField);

      // (UI) å»é™¤é‡è¤‡æ–‡å­—ï¼šä¸å†é¡¯ç¤º capLineï¼ˆä¿ç•™ä¸Šæ–¹ narrationPreview æ³¡æ³¡ï¼‰
// âœ… æ¯æ®µå¼·åº¦æ»‘æ¡¿
      const sField = document.createElement("div");
      sField.className = "field";
      const sLabel = document.createElement("div");
      sLabel.className = "miniLabel";
      sLabel.innerHTML = `<span>æœ¬æ®µå‹•æ…‹å¼·åº¦ï¼ˆä¹˜ä¸Š Auto + å…¨åŸŸï¼‰</span><span class="smallmuted">level=${shot.motionLevel || "calm"}</span>`;
      const sRow = document.createElement("div");
      sRow.className = "sliderRow";
      const sRange = document.createElement("input");
      sRange.type = "range";
      sRange.min = "0";
      sRange.max = "2";
      sRange.step = "0.05";
      sRange.value = (shot.intensity == null) ? "1" : String(shot.intensity);
      const sVal = document.createElement("div");
      sVal.className = "kv";
      sVal.textContent = (parseFloat(sRange.value)).toFixed(2);

      sRow.appendChild(sRange);
      sRow.appendChild(sVal);
      sField.appendChild(sLabel);
      sField.appendChild(sRow);
      body.appendChild(sField);

      // collapsible details (timeline workspace)
      const details = document.createElement("details");
      details.className = "details";
      details.open = false;
      const summary = document.createElement("summary");
      summary.innerHTML = `<span>ç´°ç¯€ / Prompt / éŸ³æ•ˆ / é…æ¨‚</span><span class="sumRight"><span class="chip">level=${shot.motionLevel || "calm"}</span><span class="chip">${shot.generate_sec}s</span></span>`;
      const detailsBody = document.createElement("div");
      detailsBody.className = "detailsBody";
      details.appendChild(summary);
      details.appendChild(detailsBody);

      const mini2 = document.createElement("div");
      mini2.className = "mini2";

      // left: motion prompt (editable)
      const left = document.createElement("div");
      const ll = document.createElement("div");
      ll.className = "miniLabel";
      ll.textContent = "å‹•æ…‹åŸºåº•ï¼ˆmotion promptï¼Œå¯æ‰‹æ”¹ï¼‰";
      const taMotion = document.createElement("textarea");
      taMotion.className = "miniTA";
      taMotion.value = shot.motionPrompt || "";
      left.appendChild(ll);
      left.appendChild(taMotion);

      // right: camera prompt (editable)
      const right = document.createElement("div");
      const rl = document.createElement("div");
      rl.className = "miniLabel";
      rl.textContent = "é‹é¡ï¼ˆcamera / movementï¼‰";
      const taCam = document.createElement("textarea");
      taCam.className = "miniTA";
      taCam.value = shot.cameraPrompt || "";
      right.appendChild(rl);
      right.appendChild(taCam);

      mini2.appendChild(left);
      mini2.appendChild(right);
      detailsBody.appendChild(mini2);


      // âœ… SFX / Music (editable)
      const mini2b = document.createElement("div");
      mini2b.className = "mini2";
      mini2b.style.marginTop = "10px";

      const sfxBox = document.createElement("div");
      const sfxL = document.createElement("div");
      sfxL.className = "miniLabel";
      sfxL.textContent = "éŸ³æ•ˆï¼ˆSFXï¼Œå¯æ‰‹æ”¹ï¼Œè²¼åˆ° Kling éŸ³æ•ˆæ¬„ï¼‰";
      const taSfx = document.createElement("textarea");
      taSfx.className = "miniTA";
      taSfx.value = shot.sfxPrompt || "";
      sfxBox.appendChild(sfxL);
      sfxBox.appendChild(taSfx);

      const musicBox = document.createElement("div");
      const musicL = document.createElement("div");
      musicL.className = "miniLabel";
      musicL.textContent = "é…æ¨‚ï¼ˆMusicï¼Œå¯æ‰‹æ”¹ï¼Œè²¼åˆ° Kling é…æ¨‚æ¬„ï¼‰";
      const taMusic = document.createElement("textarea");
      taMusic.className = "miniTA";
      taMusic.value = shot.musicPrompt || "";
      musicBox.appendChild(musicL);
      musicBox.appendChild(taMusic);

      mini2b.appendChild(sfxBox);
      mini2b.appendChild(musicBox);
      detailsBody.appendChild(mini2b);

      // final prompt (readonly) + copy button
      const finalWrap = document.createElement("div");
      finalWrap.className = "finalWrap";

      const fl = document.createElement("div");
      fl.className = "miniLabel";
      fl.innerHTML = `<span>æœ€çµ‚ Kling Promptï¼ˆå¯ç›´æ¥è²¼ï¼Œèˆ‡ JSON ä¸€è‡´ï¼‰</span><span class="smallmuted">${shot.generate_sec}s</span>`;

      const taFinal = document.createElement("textarea");
      taFinal.className = "miniTA finalTA";
      taFinal.readOnly = true;
      taFinal.value = buildFinalKlingPrompt(shot);


      // âœ… Final SFX / Music (readonly)
      const taFinalSfx = document.createElement("textarea");
      taFinalSfx.className = "miniTA";
      taFinalSfx.readOnly = true;
      taFinalSfx.style.marginTop = "10px";
      taFinalSfx.value = buildFinalSfxPrompt(shot);

      const taFinalMusic = document.createElement("textarea");
      taFinalMusic.className = "miniTA";
      taFinalMusic.readOnly = true;
      taFinalMusic.style.marginTop = "10px";
      taFinalMusic.value = buildFinalMusicPrompt(shot);

      const copyLine = document.createElement("div");
      copyLine.className = "copyLine";

      const btnCopyFinal = document.createElement("button");
      btnCopyFinal.className = "tinyBtn";
      btnCopyFinal.type = "button";
      btnCopyFinal.textContent = "è¤‡è£½æœ¬æ®µ Prompt";
      btnCopyFinal.addEventListener("click", async ()=>{
        try{
          await navigator.clipboard.writeText(taFinal.value);
          btnCopyFinal.textContent = "å·²è¤‡è£½ âœ“";
          setTimeout(()=>btnCopyFinal.textContent="è¤‡è£½æœ¬æ®µ Prompt", 900);
        }catch(e){
          alert("è¤‡è£½å¤±æ•—ï¼šç€è¦½å™¨æ¬Šé™é™åˆ¶");
        }
      });

      // âœ… ä¸€éµï¼šå›åˆ° Autoï¼ˆæ¸…é™¤æ‰‹æ”¹ã€ç”¨æ»‘æ¡¿æ§åˆ¶ï¼‰
      const btnBackAuto = document.createElement("button");
      btnBackAuto.className = "tinyBtn";
      btnBackAuto.type = "button";
      btnBackAuto.textContent = "å›åˆ° Auto";
      btnBackAuto.addEventListener("click", ()=>{
        shot.userEditedMotion = false;
        shot.userEditedSfx = false;
        shot.userEditedMusic = false;
        shot.motionLevel = detectMotionLevel(shot.text);
        // è§¸ç™¼é‡ç®—
        renderCards();
      });

      copyLine.appendChild(btnBackAuto);
      copyLine.appendChild(btnCopyFinal);

      
      const fl2 = document.createElement("div");
      fl2.className = "miniLabel";
      fl2.innerHTML = `<span>éŸ³æ•ˆï¼ˆSFXï¼‰â€” è²¼åˆ° Kling éŸ³æ•ˆæ¬„</span><span class="smallmuted">Auto + å…¨åŸŸ + æœ¬æ®µ</span>`;

      const fl3 = document.createElement("div");
      fl3.className = "miniLabel";
      fl3.style.marginTop = "8px";
      fl3.innerHTML = `<span>é…æ¨‚ï¼ˆMusicï¼‰â€” è²¼åˆ° Kling é…æ¨‚æ¬„</span><span class="smallmuted">Auto + å…¨åŸŸ + æœ¬æ®µ</span>`;

      const copyLine2 = document.createElement("div");
      copyLine2.className = "copyLine";
      copyLine2.style.marginTop = "8px";

      const btnCopySfx = document.createElement("button");
      btnCopySfx.className = "tinyBtn";
      btnCopySfx.type = "button";
      btnCopySfx.textContent = "è¤‡è£½éŸ³æ•ˆ";
      btnCopySfx.addEventListener("click", async ()=>{
        try{
          await navigator.clipboard.writeText(taFinalSfx.value);
          btnCopySfx.textContent = "å·²è¤‡è£½ âœ“";
          setTimeout(()=>btnCopySfx.textContent="è¤‡è£½éŸ³æ•ˆ", 900);
        }catch(e){ alert("è¤‡è£½å¤±æ•—ï¼šç€è¦½å™¨æ¬Šé™é™åˆ¶"); }
      });

      const btnCopyMusic = document.createElement("button");
      btnCopyMusic.className = "tinyBtn";
      btnCopyMusic.type = "button";
      btnCopyMusic.textContent = "è¤‡è£½é…æ¨‚";
      btnCopyMusic.addEventListener("click", async ()=>{
        try{
          await navigator.clipboard.writeText(taFinalMusic.value);
          btnCopyMusic.textContent = "å·²è¤‡è£½ âœ“";
          setTimeout(()=>btnCopyMusic.textContent="è¤‡è£½é…æ¨‚", 900);
        }catch(e){ alert("è¤‡è£½å¤±æ•—ï¼šç€è¦½å™¨æ¬Šé™é™åˆ¶"); }
      });

      copyLine2.appendChild(btnCopySfx);
      copyLine2.appendChild(btnCopyMusic);

finalWrap.appendChild(fl);
      finalWrap.appendChild(taFinal);
      finalWrap.appendChild(copyLine);
      finalWrap.appendChild(fl2);
      finalWrap.appendChild(taFinalSfx);
      finalWrap.appendChild(fl3);
      finalWrap.appendChild(taFinalMusic);
      finalWrap.appendChild(copyLine2);
      detailsBody.appendChild(finalWrap);

      const info = document.createElement("div");
      info.className = "smallmuted";
      info.style.marginTop = "10px";
        const _imgName = (shot.image && shot.image.name) ? shot.image.name : (shot.imageName || shot.name || "");
        info.textContent = `${String(shot.idx).padStart(4,"0")}  ${_imgName}`;
      detailsBody.appendChild(info);

      // mount details into body (collapsed by default)
      body.appendChild(details);

      function refreshFinal(){
        taFinal.value = buildFinalKlingPrompt(shot);
        taFinalSfx.value = buildFinalSfxPrompt(shot);
        taFinalMusic.value = buildFinalMusicPrompt(shot);
      }

      // slider per shot changes
      sRange.addEventListener("input", ()=>{
        shot.intensity = parseFloat(sRange.value || "1") || 1;
        sVal.textContent = (shot.intensity).toFixed(2);

        // è‹¥é‚„åœ¨ auto æ¨¡å¼ï¼Œé‡ç®— motionPrompt
        if(!shot.userEditedMotion){
          const lvl2 = shot.motionLevel || detectMotionLevel(shot.text);
          const base = baseFactorForLevel(lvl2);
          const factor = base * (parseFloat(el("globalIntensity").value || "1") || 1) * shot.intensity;
          shot.motionPrompt = buildMotionTemplate(lvl2, factor);
          taMotion.value = shot.motionPrompt;
        }
        refreshFinal();
      });

      // live sync for motion/camera manual edits
      taMotion.addEventListener("input", ()=>{
        shot.motionPrompt = taMotion.value;
        shot.userEditedMotion = true; // âœ… æ‰‹å‹•æ”¹äº†å°±ä¸å† auto è¦†è“‹
        refreshFinal();
      });
      taCam.addEventListener("input", ()=>{
        shot.cameraPrompt = taCam.value;
        refreshFinal();
      });

      taSfx.addEventListener("input", ()=>{
        shot.sfxPrompt = taSfx.value;
        shot.userEditedSfx = true;
        refreshFinal();
      });
      taMusic.addEventListener("input", ()=>{
        shot.musicPrompt = taMusic.value;
        shot.userEditedMusic = true;
        refreshFinal();
      });

      card.appendChild(tlRail);
      card.appendChild(thumb);
      card.appendChild(body);
      cards.appendChild(card);
    }

    updateTopMeta();
    updateKlingCount();
    updateFilterHint();
    el("copyJsonBtn").disabled = state.shots.length === 0;
    el("downloadJsonBtn").disabled = state.shots.length === 0;
    el("exportOk2ZipBtn").disabled = state.shots.length === 0;
  }

  
  async function captureFrameAt(videoEl, t){
    // clamp
    const dur = videoEl.duration || 0;
    if(dur > 0){
      t = Math.max(0, Math.min(dur - 0.05, t));
    }else{
      t = Math.max(0, t);
    }

    // seek
    await new Promise((resolve, reject)=>{
      const onSeeked = ()=>{
        videoEl.removeEventListener("seeked", onSeeked);
        videoEl.removeEventListener("error", onErr);
        resolve();
      };
      const onErr = ()=>{
        videoEl.removeEventListener("seeked", onSeeked);
        videoEl.removeEventListener("error", onErr);
        reject(new Error("å½±ç‰‡ seek å¤±æ•—"));
      };
      videoEl.addEventListener("seeked", onSeeked, {once:true});
      videoEl.addEventListener("error", onErr, {once:true});
      try{
        videoEl.currentTime = t;
      }catch(e){
        reject(e);
      }
    });

    // draw
    const c = captureFrameAt._canvas || (captureFrameAt._canvas = document.createElement("canvas"));
    const w = videoEl.videoWidth || 1280;
    const h = videoEl.videoHeight || 720;
    c.width = w; c.height = h;
    const ctx = c.getContext("2d");
    ctx.drawImage(videoEl, 0, 0, w, h);
    // jpeg is smaller and good enough
    return c.toDataURL("image/jpeg", 0.92);
  }

  function safeBaseFromVideoName(name){
    return (name || "source").replace(/\.[^.]+$/,'');
  }

  async function buildShots(){
    if(!state.video){ alert("è«‹å…ˆåŒ¯å…¥æºé ­ MP4"); return; }
    if(!state.srtText){ alert("è«‹å…ˆåŒ¯å…¥ SRT"); return; }

    const v = el("srcVideo");
    if(!v || !v.duration){ 
      // still try, but warn
      console.warn("video duration not ready");
    }

    const minSec = Math.max(1, parseInt(el("minSec").value || "1", 10));
    const maxSec = Math.max(minSec, parseInt(el("maxSec").value || String(minSec), 10));

    state.cues = parseSrt(state.srtText);

    const mode = el("alignMode").value;
    if(mode === "fixed"){
      // èˆŠæ¨¡å¼ï¼šç‰‡é ­ 2 ç§’ + å…¶é¤˜ 10 ç§’ï¼ˆä»¥æ™‚é–“è»¸åˆ‡ï¼Œä¸å†é åœ–ç‰‡æ•¸ï¼‰
      const firstSec = 2;
      const restSec = 10;
      // ç”¨å½±ç‰‡é•·åº¦ä¼°ç®—æ®µæ•¸
      const dur = v.duration || (state.cues.length ? state.cues[state.cues.length-1].end : 0);
      const count = Math.max(1, Math.ceil((Math.max(0,dur-firstSec))/restSec) + 1);
      state.chunks = [];
      let t = 0;
      for(let i=0;i<count;i++){
        const segDur = (i===0) ? firstSec : restSec;
        const start = t;
        const end = t + segDur;
        t = end;
        // collect texts that start inside [start,end)
        const texts = [];
        for(const cue of state.cues){
          if(cue.start >= start && cue.start < end) texts.push(cue.text);
        }
        const unique = Array.from(new Set(texts.map(t=>String(t||"").replace(/\s+/g," ").trim()).filter(Boolean)));
        state.chunks.push({start, end, text: unique.join(" ")});
      }
    }else{
      // âœ… OK02 auto_reimage_srt.py åŒæ¬¾ï¼šSRT è‡ªç„¶åˆ†æ®µ
      const maxGap = Math.max(0, parseFloat(el("maxGap").value || "1.5"));
      const maxSent = Math.max(1, parseInt(el("maxSent").value || "3", 10));
      state.chunks = buildSegmentsLikeOK02(state.cues, maxSec, maxSent, maxGap);
    }

    // base
    state.baseName = safeBaseFromVideoName(state.video.name);

    const cfg = getModeConfig();
    const cat = el("catSelect").value;
    const style = el("styleSelect").value;

    // capture frames for each chunk
    setStatus(`æˆªåœ–ä¸­... 0/${state.chunks.length}`);
    state.images = [];
    for(let i=0;i<state.chunks.length;i++){
      const ch = state.chunks[i];
      const mid = (ch.start + ch.end) / 2;
      // prefer start+0.25s to avoid black frame, fallback mid
      const t1 = Math.min(ch.end - 0.10, ch.start + 0.25);
      const t = (isFinite(t1) && t1 > ch.start) ? t1 : mid;
      let dataUrl = "";
      try{
        dataUrl = await captureFrameAt(v, t);
      }catch(e){
        console.warn("capture failed, fallback mid", e);
        try{ dataUrl = await captureFrameAt(v, mid); }catch(e2){ dataUrl = ""; }
      }
      const name = `${state.baseName}_${pad4(i+1)}.jpg`;
      state.images.push({name, url: dataUrl || ""});
      setStatus(`æˆªåœ–ä¸­... ${i+1}/${state.chunks.length}`);
    }

    // build shots list
    const n = state.chunks.length;
    state.shots = [];
    for(let i=0;i<n;i++){
      const ch = state.chunks[i];
      const img = state.images[i] || {name:`${state.baseName}_${pad4(i+1)}.jpg`, url:""};
      const rawText = (ch.text || "").trim();
      const ex = extractRoleFromText(rawText);
      const role = ex.role || "NARRATOR";
      const narration = (ex.text || "").trim();
      const lvl = detectMotionLevel(narration);

      const shot = {
        id: i+1,
        idx: i+1,
        image: img,
        imageName: img && img.name ? img.name : undefined,
        imageUrl: img && img.url ? img.url : undefined,
        start: ch.start,
        end: ch.end,
        dur: ch.dur,
        text: narration,
        role,
        rawText,
        motion: lvl,
        prompt: "",
        useSegMp4: true,        // è‹¥ reimage_output æœ‰åŒç·¨è™Ÿ mp4ï¼Œå„ªå…ˆå–ç”¨
        voiceCfg: deepClone(roleVoiceMap[role] || roleVoiceMap["NARRATOR"] || DEFAULT_ROLE_VOICE_MAP["NARRATOR"]),
        voiceDirty: false,
        userEditedVoice: false,
      };
      state.shots.push(shot);
}

    setStatus(`å·²ç”¢ç”Ÿ ${state.shots.length} æ®µ`);
    renderCards();
  }


  function buildJson(){
    const cfg = getModeConfig();
    const base = state.baseName || safeBaseFromImages(state.images);
    const globalTail = getGlobalTail();
    const globalIntensity = parseFloat(el("globalIntensity").value || "1") || 1;

    return {
      meta: {
        base,
        category: el("catSelect").value,
        style: el("styleSelect").value,
        mode: cfg.mode,
        kling_generate_sec: cfg.generateSec,
        target_sec: cfg.targetSec,
        stretch_factor: cfg.stretchFactor,
        mp3_sec: 10,
        min_chunk_sec: parseInt(el("minSec").value || "10", 10),
        max_chunk_sec: parseInt(el("maxSec").value || "10", 10),
        global_suffix: globalTail || null,
        global_sfx: getGlobalSfx() || null,
        global_music: getGlobalMusic() || null,

        // âœ… æ–°å¢ï¼šå¼·åº¦è³‡è¨Šï¼ˆä¸å½±éŸ¿ä½ ä¸‹æ¸¸ï¼Œåªæ˜¯å‚™è¨»ï¼‰
        auto_motion: true,
        global_intensity: globalIntensity,
        kling_only_selected: true,
        kling_selected_count: state.shots.filter(s=>!!s.use_kling).length,

        created_at: new Date().toISOString()
      },
      shots: state.shots.map(s => ({
        id: s.id,
        use_kling: !!s.use_kling,

        image_name: s.image.name,
        srt_start: s.start,
        srt_end: s.end,
        narration: s.text,

        // âœ… ä¸‹æ¸¸ç”¨çš„æ™‚é–“
        generate_sec: s.generate_sec,
        target_sec: s.target_sec,
        stretch_factor: s.stretch_factor,

        // âœ… é™„ä¸Šåˆ¤æ–·çµæœï¼ˆå‚™è¨»/å¯å›æº¯ï¼‰
        motion_level: s.motionLevel,
        per_shot_intensity: s.intensity,

        // âœ… æœ€é‡è¦ï¼šæœ€çµ‚å¯è²¼ prompt
        kling_prompt: buildFinalKlingPrompt(s),
        sfx_prompt: buildFinalSfxPrompt(s),
        music_prompt: buildFinalMusicPrompt(s)
      }))
    };
  }

  
  // ===== TTS preview + mp3 cache (IndexedDB) =====
  const AZURE_TTS_URL = "https://jeajrwpmrgczimmrflxo.supabase.co/functions/v1/azure-tts";

  // ===== Role â†’ Voice (global) =====
  const ROLE_VOICE_STORAGE_KEY = "bw_role_voice_map_v1";
  const DEFAULT_ROLE_VOICE_MAP = {
    "NARRATOR":  { voice: "en-US-JennyNeural", rate: "+0%",  pitch: "+0Hz",   volume: "+0%" },
    "LION":      { voice: "en-US-GuyNeural",   rate: "-5%",  pitch: "-20Hz",  volume: "+0%" },
    "MOUSE":     { voice: "en-US-AriaNeural",  rate: "+10%", pitch: "+40Hz",  volume: "+0%" },
    "MOM_DUCK":  { voice: "en-US-JennyNeural", rate: "+5%",  pitch: "+30Hz",  volume: "+0%" },
    "DUCKLING":  { voice: "en-US-AnaNeural",   rate: "+15%", pitch: "+60Hz",  volume: "+0%" },
  };

  const ROLE_VOICE_CHOICES = [
    ["en-US-JennyNeural", "å¥³è² Jenny"],
    ["en-US-AriaNeural", "å¥³è² Aria"],
    ["en-US-AnaNeural", "å¥³è² Ana"],
    ["en-US-GuyNeural", "ç”·è² Guy"],
    ["en-US-DavisNeural", "ç”·è² Davis"],
    ["en-US-BrandonNeural", "ç”·è² Brandon"],
    ["en-US-ChristopherNeural", "ç”·è² Christopher"],
  ];

  function deepClone(o){ return JSON.parse(JSON.stringify(o)); }

  function normalizeRoleName(r){
    return (r || "").toString().trim().toUpperCase().replace(/\s+/g, "_");
  }

  function loadRoleVoiceMap(){
    try{
      const raw = localStorage.getItem(ROLE_VOICE_STORAGE_KEY);
      if(!raw) return deepClone(DEFAULT_ROLE_VOICE_MAP);
      const parsed = JSON.parse(raw);
      // merge defaults (keep user extras)
      const merged = deepClone(DEFAULT_ROLE_VOICE_MAP);
      for(const k of Object.keys(parsed||{})){
        merged[normalizeRoleName(k)] = parsed[k];
      }
      return merged;
    }catch(e){
      return deepClone(DEFAULT_ROLE_VOICE_MAP);
    }
  }

  function saveRoleVoiceMap(map){
    const out = {};
    for(const k of Object.keys(map||{})){
      const nk = normalizeRoleName(k);
      if(!nk) continue;
      out[nk] = map[k];
    }
    localStorage.setItem(ROLE_VOICE_STORAGE_KEY, JSON.stringify(out));
  }

  let roleVoiceMap = loadRoleVoiceMap();

  function extractRoleFromText(text){
    const t = (text || "").toString().trim();
    // [ROLE] text
    let m = t.match(/^\[([^\]]{1,40})\]\s*(.*)$/);
    if(m){
      return { role: normalizeRoleName(m[1]), text: (m[2]||"").trim() };
    }
    // ROLE: text
    m = t.match(/^([A-Za-z0-9_\-]{2,40})\s*:\s*(.*)$/);
    if(m){
      return { role: normalizeRoleName(m[1]), text: (m[2]||"").trim() };
    }
    return { role: "NARRATOR", text: t };
  }

  function applyRoleToShot(shot){
    if(!shot) return;
    const role = normalizeRoleName(shot.role || "NARRATOR") || "NARRATOR";
    shot.role = role;
    if(shot.userEditedVoice) return; // å–®å¥å·²æ‰‹å‹•èª¿è²éŸ³ï¼šä¸è¦è¦†è“‹
    if(roleVoiceMap[role]){
      shot.voiceCfg = deepClone(roleVoiceMap[role]);
    } else {
      shot.voiceCfg = deepClone(roleVoiceMap["NARRATOR"] || DEFAULT_ROLE_VOICE_MAP["NARRATOR"]);
    }
  }



  function markVoiceDirty(shot){
  shot.voiceDirty = true;

  // âœ… ä¸è¦æ•´é é‡ç¹ªï¼ˆæœƒæŠŠç•«é¢æ²å›æœ€ä¸Šé¢ï¼‰
  // åªæ›´æ–°è©²æ®µçš„ã€Œå·²æ”¹/æœªæ”¹ã€æ¨™è¨˜å³å¯
  const tag = document.querySelector(`.dirtyTag[data-segid="${shot.id}"]`);
  if(tag){
    tag.classList.add("on");
    tag.textContent = "å·²æ”¹";
  }
  updateExportButtons();
}

  function getShotVoice(shot){
    const v = shot.voiceCfg || { voice:"en-US-JennyNeural", rate:"+0%", pitch:"+0Hz", volume:"+0%" };
    return {
      voice: (v.voice || "en-US-JennyNeural"),
      rate: (v.rate || "+0%"),
      pitch: (v.pitch || "+0Hz"),
      volume: (v.volume || "+0%")
    };
  }

          async function previewTTSWithText(shot, textOverride){
          const {voice, rate, pitch, volume} = getShotVoice(shot);
          const text = String(textOverride || "").trim();
          if(!text){
            alert("æ­¤æ®µæ²’æœ‰æ–‡å­—ï¼Œç„¡æ³•è©¦è½ã€‚");
            return;
          }
          try{
            const url = await ttsFetchAudioUrl({ text, voice, rate, pitch, volume });
            playAudioUrl(url);
          }catch(err){
            console.error(err);
            alert("è©¦è½å¤±æ•—ï¼ˆå¯èƒ½ç¶²è·¯/æœå‹™ä¸å¯ç”¨ï¼‰ã€‚");
          }
        }


function splitSentencesGlobal(txt){
  const s = String(txt||"").trim();
  if(!s) return [];
  const out = [];
  let cur = "";
  for(const ch of s){
    cur += ch;
    if(ch==="." || ch==="?" || ch==="!"){
      const c = cur.trim();
      if(c) out.push(c);
      cur = "";
    }
  }
  const tail = cur.trim();
  if(tail) out.push(tail);
  return out.length ? out : [s];
}

function stripID3(u8){
  if(u8.length >= 10 && u8[0]===0x49 && u8[1]===0x44 && u8[2]===0x33){
    const size = ((u8[6]&0x7f)<<21) | ((u8[7]&0x7f)<<14) | ((u8[8]&0x7f)<<7) | (u8[9]&0x7f);
    const total = 10 + size;
    if(total < u8.length) return u8.slice(total);
  }
  return u8;
}

async function synthTTSBlob(text, voiceCfg){
  const {voice, rate, pitch, volume} = voiceCfg;
  const body = { text, lang:"en", voice, rate, pitch, volume };
  const res = await fetch(AZURE_TTS_URL, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify(body)
  });
  if(!res.ok){
    const t = await res.text();
    throw new Error("TTS failed: " + t);
  }
  return await res.blob();
}

async function synthTTSMp3Bytes(text, voiceCfg){
  const blob = await synthTTSBlob(text, voiceCfg);
  const ab = await blob.arrayBuffer();
  return new Uint8Array(ab);
}

async function concatMp3FromParts(parts){
  const clean = parts.map((p)=> stripID3(p));
  const total = clean.reduce((s,p)=> s+p.length, 0);
  const out = new Uint8Array(total);
  let off=0;
  for(const p of clean){
    out.set(p, off);
    off += p.length;
  }
  return new Blob([out], {type:"audio/mpeg"});
}

function ensureMultiVoice(shot){
  if(shot.multiVoice && Array.isArray(shot.multiVoice) && shot.multiVoice.length) return;
  const sentences = splitSentencesGlobal(shot.text||"");
  const base = getShotVoice(shot);
  if(sentences.length<=1){
    shot.multiVoice = [{ text: (shot.text||"").trim(), cfg: {...base} }];
    return;
  }
  shot.multiVoice = sentences.map(t=>({ text:t, cfg: {...base} }));
}

async function previewTTSForShot(shot){
    const {voice, rate, pitch, volume} = getShotVoice(shot);
    const text = (shot.text || "").trim();
    if(!text){
      alert("æ­¤æ®µæ²’æœ‰æ–‡å­—ï¼Œç„¡æ³•è©¦è½ã€‚");
      return;
    }
    const body = {
      text,
      lang: "en", // èˆŠç‰ˆå…¼å®¹ï¼šä½ çš„ function ç›®å‰ç”¨ en/zh/jaã€‚è‹¥ä½ æ”¹æˆ en-US ä¹Ÿå¯åœ¨ function ç«¯å…¼å®¹ã€‚
      voice,
      rate,
      pitch,
      volume
    };
    const res = await fetch(AZURE_TTS_URL, {
      method: "POST",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify(body)
    });
    if(!res.ok){
      const t = await res.text();
      throw new Error("TTS failed: " + t);
    }
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const a = new Audio(url);
    a.play();
    a.onended = ()=> URL.revokeObjectURL(url);
  }

  async function sha1Hex(str){
    const enc = new TextEncoder().encode(str);
    const buf = await crypto.subtle.digest("SHA-1", enc);
    return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join("");
  }

  // IndexedDB minimal wrapper
  function idbOpen(){
    return new Promise((resolve, reject)=>{
      const req = indexedDB.open("bw_tts_cache_v1", 1);
      req.onupgradeneeded = ()=>{
        const db = req.result;
        if(!db.objectStoreNames.contains("mp3")){
          db.createObjectStore("mp3", { keyPath: "id" });
        }
      };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }

  async function idbGet(id){
    const db = await idbOpen();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction("mp3", "readonly");
      const st = tx.objectStore("mp3");
      const rq = st.get(id);
      rq.onsuccess = ()=> resolve(rq.result || null);
      rq.onerror = ()=> reject(rq.error);
    });
  }

  async function idbPut(rec){
    const db = await idbOpen();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction("mp3", "readwrite");
      const st = tx.objectStore("mp3");
      const rq = st.put(rec);
      rq.onsuccess = ()=> resolve(true);
      rq.onerror = ()=> reject(rq.error);
    });
  }

  function buildOk2Manifest(){
    const base = state.baseName || safeBaseFromImages(state.images) || "story";
    return {
      meta: {
        base,
        source_mp4: (state.mp4FileName || null),
        source_srt: (state.srtFileName || null),
        mode: "srt_natural",
        created_at: new Date().toISOString()
      },
      segments: state.shots.map(s => ({
        id: s.id,
        start: s.start,
        end: s.end,
        text: (s.text || "").trim(),
        image_prompt: buildFinalKlingPrompt(s),
        use_kling: !!s.use_kling
      }))
    };
  }

  function buildOverridesAll(){
    // å…¨æ®µè¼¸å‡ºï¼ˆæ–¹ä¾¿è¿½æº¯ï¼‰ï¼Œok2 å¯ä¸ä½¿ç”¨ voiceï¼Œä½†ä¿ç•™
    const voice = {};
    for(const s of state.shots){
      const v = getShotVoice(s);
      voice[s.id] = v;
    }
    return { voice };
  }

  async function getOrGenMp3ForSegment(seg){
    // âœ… å¤šè²æ¨¡å¼ï¼šåŒä¸€æ®µå…§åˆ†å¥ä¸åŒè²éŸ³ï¼Œä½†åŒ¯å‡ºä» 1 å€‹ mp3ï¼ˆæ®µæ•¸ä¸å¢åŠ ï¼‰
    if(seg.multiVoiceEnabled){
      ensureMultiVoice(seg);
      const partsKey = seg.multiVoice.map(p=>{
        const c = p.cfg || {};
        return [String(p.text||"").trim(), c.voice||"", c.rate||"", c.pitch||"", c.volume||""].join("|");
      }).join("||");
      const hash = await sha1Hex("MULTI||" + partsKey);
      const cached = await idbGet(seg.id);
      if(cached && cached.hash === hash && cached.blob){
        return { blob: cached.blob, hash, reused: true };
      }
      // generate each sentence mp3 then concat bytes (mp3 frame concat)
      const bytes = [];
      for(const p of seg.multiVoice){
        const t = String(p.text||"").trim();
        if(!t) continue;
        const cfg = p.cfg || getShotVoice(seg);
        bytes.push(await synthTTSMp3Bytes(t, cfg));
      }
      const blob = await concatMp3FromParts(bytes);
      await idbPut({ id: seg.id, hash, blob, saved_at: Date.now() });
      seg.voiceDirty = false;
      return { blob, hash, reused: false };
    }

    // å–®è²æ¨¡å¼ï¼ˆåŸæœ¬ï¼‰
    const v = getShotVoice(seg);
    const text = (seg.text || "").trim();
    const hash = await sha1Hex([text, v.voice, v.rate, v.pitch, v.volume].join("|"));
    const cached = await idbGet(seg.id);
    if(cached && cached.hash === hash && cached.blob){
      return { blob: cached.blob, hash, reused: true };
    }
    const body = { text, lang:"en", voice:v.voice, rate:v.rate, pitch:v.pitch, volume:v.volume };
    const res = await fetch(AZURE_TTS_URL, { method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify(body) });
    if(!res.ok){
      const t = await res.text();
      throw new Error(`TTS failed on ${seg.id}: ${t}`);
    }
    const blob = await res.blob();
    await idbPut({ id: seg.id, hash, blob, saved_at: Date.now() });
    seg.voiceDirty = false;
    return { blob, hash, reused: false };
  }


function openMultiVoiceModal(shot){
  ensureMultiVoice(shot);
  const modal = document.getElementById("multiVoiceModal");
  const panel = modal.querySelector(".panel");
  panel.innerHTML = "";

  const top = document.createElement("div");
  top.className = "topbar";
  const title = document.createElement("div");
  title.className = "title";
  title.textContent = `å¥å…§å¤šè²ï¼ˆç¶­æŒæ®µæ•¸ï¼‰ â€” #${shot.id}`;

  const actions = document.createElement("div");
  actions.style.display="flex";
  actions.style.gap="8px";

  const btnClose = document.createElement("button");
  btnClose.className = "btn";
  btnClose.textContent = "é—œé–‰";
  btnClose.onclick = ()=>{ modal.style.display="none"; };

  const btnPreview = document.createElement("button");
  btnPreview.className = "btn primary";
  btnPreview.textContent = "â–¶ è©¦è½å¤šè²";
  btnPreview.onclick = async ()=>{
    btnPreview.disabled = true;
    const old = btnPreview.textContent;
    btnPreview.textContent = "ç”¢ç”Ÿä¸­...";
    try{
      const parts = [];
      for(const p of shot.multiVoice){
        const t = String(p.text||"").trim();
        if(!t) continue;
        parts.push(await synthTTSMp3Bytes(t, p.cfg));
      }
      const blob = await concatMp3FromParts(parts);
      const url = URL.createObjectURL(blob);
      const a = new Audio(url);
      a.play();
      a.onended = ()=> URL.revokeObjectURL(url);
    }catch(e){
      alert(String(e));
      console.error(e);
    }finally{
      btnPreview.disabled = false;
      btnPreview.textContent = old;
    }
  };

  const btnApply = document.createElement("button");
  btnApply.className = "btn";
  btnApply.textContent = "å„²å­˜";
  btnApply.onclick = ()=>{
    shot.multiVoiceEnabled = true;
    shot.voiceDirty = true;
    modal.style.display="none";
    updateExportButtons();
    const tag = document.querySelector(`.dirtyTag[data-segid="${shot.id}"]`);
    if(tag){ tag.classList.add("on"); tag.textContent="å·²æ”¹"; }
  };

  actions.appendChild(btnPreview);
  actions.appendChild(btnApply);
  actions.appendChild(btnClose);

  top.appendChild(title);
  top.appendChild(actions);
  panel.appendChild(top);

  const VOICES = [
    {v:"en-US-JennyNeural", t:"å¥³è² Jenny"},
    {v:"en-US-GuyNeural", t:"ç”·è² Guy"},
    {v:"en-US-AriaNeural", t:"ç”œç¾å¥³ Aria"},
    {v:"en-US-AmberNeural", t:"å¥³å­© Amber"},
    {v:"en-US-AnaNeural", t:"å°å¥³ Ana"},
    {v:"en-US-DavisNeural", t:"æˆç†Ÿç”· Davis"}
  ];

  shot.multiVoice.forEach((p)=>{
    const row = document.createElement("div");
    row.className = "row";

    const txt = document.createElement("div");
    txt.className = "txt";
    txt.textContent = p.text;

    const sel = document.createElement("select");
    sel.className = "miniSel";
    VOICES.forEach(o=>{
      const opt=document.createElement("option");
      opt.value=o.v; opt.textContent=o.t;
      sel.appendChild(opt);
    });
    sel.value = p.cfg.voice || "en-US-JennyNeural";
    sel.onchange = ()=>{ p.cfg.voice = sel.value; };

    const rate = document.createElement("input");
    rate.className="miniInp"; rate.style.width="88px";
    rate.value = p.cfg.rate || "+0%";
    rate.oninput = ()=>{ p.cfg.rate = rate.value.trim(); };

    const pitch = document.createElement("input");
    pitch.className="miniInp"; pitch.style.width="88px";
    pitch.value = p.cfg.pitch || "+0Hz";
    pitch.oninput = ()=>{ p.cfg.pitch = pitch.value.trim(); };

    const vol = document.createElement("input");
    vol.className="miniInp"; vol.style.width="88px";
    vol.value = p.cfg.volume || "+0%";
    vol.oninput = ()=>{ p.cfg.volume = vol.value.trim(); };

    const btnThis = document.createElement("button");
    btnThis.className="btn";
    btnThis.textContent="â–¶ æ­¤å¥";
    btnThis.onclick = async ()=>{
      btnThis.disabled=true;
      try{
        const blob = await synthTTSBlob(p.text, p.cfg);
        const url = URL.createObjectURL(blob);
        const a = new Audio(url);
        a.play();
        a.onended = ()=> URL.revokeObjectURL(url);
      }catch(e){
        alert(String(e));
        console.error(e);
      }finally{
        btnThis.disabled=false;
      }
    };

    row.appendChild(txt);
    row.appendChild(sel);
    row.appendChild(rate);
    row.appendChild(pitch);
    row.appendChild(vol);
    row.appendChild(btnThis);
    panel.appendChild(row);
  });

  modal.style.display="flex";
  modal.onclick = (e)=>{ if(e.target===modal) modal.style.display="none"; };
}


function genSplitId(baseId, k){
  // baseId like "0020" -> "0020-1", "0020-2" ...
  const m = String(baseId).match(/\d+/);
  const digits = m ? m[0] : String(baseId);
  return `${digits}-${k+1}`;
}


  // ===== Role Voice Modal =====
  const roleVoiceModal = document.getElementById("roleVoiceModal");
  const roleVoiceBody  = document.getElementById("roleVoiceBody");
  const btnRoleVoice   = document.getElementById("btnRoleVoice");
  const btnRoleAdd     = document.getElementById("btnRoleAdd");
  const btnRoleSave    = document.getElementById("btnRoleSave");
  const btnRoleClose   = document.getElementById("btnRoleClose");

  function renderRoleVoiceModal(){
    roleVoiceBody.innerHTML = "";
    const roles = Object.keys(roleVoiceMap || {}).sort();
    const wrap = document.createElement("div");
    wrap.className = "mvList";
    for(const role of roles){
      const cfg = roleVoiceMap[role] || {};
      const row = document.createElement("div");
      row.className = "mvItem";

      const left = document.createElement("div");
      left.innerHTML = `
        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
          <span class="pill" style="font-weight:800;">${escapeHtml(role)}</span>
          <button class="btn ghost" data-role-del="${escapeHtml(role)}">åˆªé™¤</button>
        </div>
      `;

      const right = document.createElement("div");
      right.innerHTML = `
        <div class="mvGrid">
          <label>è²éŸ³
            <select data-role-voice="${escapeHtml(role)}">
              ${ROLE_VOICE_CHOICES.map(([v,n]) => `<option value="${v}" ${v===cfg.voice?'selected':''}>${n} (${v})</option>`).join("")}
            </select>
          </label>
          <label>èªé€Ÿ
            <input data-role-rate="${escapeHtml(role)}" value="${cfg.rate ?? '+0%'}" placeholder="+0%">
          </label>
          <label>éŸ³é«˜
            <input data-role-pitch="${escapeHtml(role)}" value="${cfg.pitch ?? '+0Hz'}" placeholder="+0Hz">
          </label>
          <label>éŸ³é‡
            <input data-role-vol="${escapeHtml(role)}" value="${cfg.volume ?? '+0%'}" placeholder="+0%">
          </label>
        </div>
      `;
      row.appendChild(left);
      row.appendChild(right);
      wrap.appendChild(row);
    }
    roleVoiceBody.appendChild(wrap);

    roleVoiceBody.querySelectorAll("[data-role-del]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const r = btn.getAttribute("data-role-del");
        if(r==="NARRATOR"){ toast("NARRATOR ä¸èƒ½åˆª"); return; }
        delete roleVoiceMap[r];
        renderRoleVoiceModal();
      });
    });
  }

  function openRoleVoiceModal(){
    roleVoiceMap = loadRoleVoiceMap();
    renderRoleVoiceModal();
    roleVoiceModal.style.display = "flex";
  }

  function closeRoleVoiceModal(){
    roleVoiceModal.style.display = "none";
  }

  function collectRoleVoiceModal(){
    const map = {};
    for(const role of Object.keys(roleVoiceMap||{})){
      map[role] = roleVoiceMap[role];
    }
    // collect inputs
    roleVoiceBody.querySelectorAll("select[data-role-voice]").forEach(sel=>{
      const role = sel.getAttribute("data-role-voice");
      map[role] = map[role] || {};
      map[role].voice = sel.value;
    });
    roleVoiceBody.querySelectorAll("input[data-role-rate]").forEach(inp=>{
      const role = inp.getAttribute("data-role-rate");
      map[role] = map[role] || {};
      map[role].rate = (inp.value||"+0%").trim();
    });
    roleVoiceBody.querySelectorAll("input[data-role-pitch]").forEach(inp=>{
      const role = inp.getAttribute("data-role-pitch");
      map[role] = map[role] || {};
      map[role].pitch = (inp.value||"+0Hz").trim();
    });
    roleVoiceBody.querySelectorAll("input[data-role-vol]").forEach(inp=>{
      const role = inp.getAttribute("data-role-vol");
      map[role] = map[role] || {};
      map[role].volume = (inp.value||"+0%").trim();
    });
    // normalize keys
    const out = {};
    for(const k of Object.keys(map)){
      const nk = normalizeRoleName(k);
      if(!nk) continue;
      out[nk] = map[k];
    }
    if(!out["NARRATOR"]) out["NARRATOR"] = deepClone(DEFAULT_ROLE_VOICE_MAP["NARRATOR"]);
    return out;
  }

  if(btnRoleVoice){
    btnRoleVoice.addEventListener("click", openRoleVoiceModal);
  }
  if(btnRoleClose){
    btnRoleClose.addEventListener("click", closeRoleVoiceModal);
  }
  if(btnRoleAdd){
    btnRoleAdd.addEventListener("click", ()=>{
      const name = prompt("è¼¸å…¥è§’è‰²åï¼ˆä¾‹å¦‚ LION / MOM_DUCKï¼‰");
      if(!name) return;
      const role = normalizeRoleName(name);
      if(!role) return;
      roleVoiceMap[role] = roleVoiceMap[role] || deepClone(DEFAULT_ROLE_VOICE_MAP["NARRATOR"]);
      renderRoleVoiceModal();
    });
  }
  if(btnRoleSave){
    btnRoleSave.addEventListener("click", ()=>{
      const out = collectRoleVoiceModal();
      saveRoleVoiceMap(out);
      roleVoiceMap = out;
      toast("å·²å„²å­˜è§’è‰²è²éŸ³è¡¨");
      // é‡æ–°å¥—ç”¨åˆ°ç¾æœ‰ shotsï¼ˆåƒ…é™æœªæ‰‹å‹•èª¿éè²éŸ³ï¼‰
      for(const sh of (state.shots||[])){
        if(sh && !sh.userEditedVoice){
          sh.role = normalizeRoleName(sh.role || "NARRATOR") || "NARRATOR";
          sh.voiceCfg = deepClone(roleVoiceMap[sh.role] || roleVoiceMap["NARRATOR"] || DEFAULT_ROLE_VOICE_MAP["NARRATOR"]);
        }
      }
      renderShots();
    });
  }

  roleVoiceModal?.addEventListener("click", (e)=>{
    if(e.target === roleVoiceModal) closeRoleVoiceModal();
  });


function splitShotBySentences(shot){
  const idx = (state.shots||[]).findIndex(s=>s===shot || s.id===shot.id);
  if(idx<0) return;

  const s = String(shot.text||"").trim();
  if(!s){ alert("æ­¤æ®µæ²’æœ‰æ–‡å­—"); return; }

  // Split by . ? ! while keeping punctuation
  const arr = (function splitSentences(txt){
    const s = String(txt||"").trim();
    if(!s) return [];
    const out = [];
    let cur = "";
    for(const ch of s){
      cur += ch;
      if(ch==="." || ch==="?" || ch==="!"){
        const c = cur.trim();
        if(c) out.push(c);
        cur = "";
      }
    }
    const tail = cur.trim();
    if(tail) out.push(tail);
    return out.length ? out : [s];
  })(s);

  if(arr.length<=1){
    alert("é€™æ®µåªæœ‰ 1 å¥ï¼Œä¸éœ€è¦åˆ‡æ®µ");
    return;
  }

  const dur = Math.max(0.01, (shot.end - shot.start));
  const step = dur / arr.length;

  const baseId = shot.id;
  const baseStart = shot.start;

  // Keep first sentence in current shot
  shot.text = arr[0];
  shot.end = baseStart + step;

  const newShots = [];
  for(let i=1;i<arr.length;i++){
    const ns = JSON.parse(JSON.stringify(shot));
    ns.id = genSplitId(baseId, i-1); // -1, -2...
    ns.text = arr[i];
    ns.start = baseStart + step*i;
    ns.end = (i===arr.length-1) ? (baseStart + dur) : (baseStart + step*(i+1));
    newShots.push(ns);
  }

  state.shots.splice(idx+1, 0, ...newShots);

  shot.voiceDirty = true;
  for(const ns of newShots) ns.voiceDirty = true;

  renderCards();
  updateExportButtons();

  setTimeout(()=>{
    const el = document.querySelector(`[data-card-segid="${shot.id}"]`);
    if(el) el.scrollIntoView({behavior:"smooth", block:"center"});
  }, 60);
}
function updateExportButtons(){
    const ok = state.shots && state.shots.length > 0;
    const b = el("exportOk2ZipBtn");
    if(b) b.disabled = !ok;
  }


async function copyJson(){
    const payload = buildJson();
    await navigator.clipboard.writeText(JSON.stringify(payload, null, 2));
    alert("å·²è¤‡è£½ JSON");
  }
  function downloadJson(){
    const payload = buildJson();
    const txt = JSON.stringify(payload, null, 2);
    const base = state.baseName || safeBaseFromImages(state.images) || "kling";
    const blob = new Blob([txt], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `${baseName}_kling.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
  }

  // ===== bindings =====
  
  // ===== bindings =====
  el("mp4Input").addEventListener("change", async (e)=>{
    const f = (e.target.files && e.target.files[0]) ? e.target.files[0] : null;
    const v = el("srcVideo");
    if(!f){
      try{ if(state.video?.url) URL.revokeObjectURL(state.video.url); }catch{}
      state.video = null;
      state.images = [];
      el("mp4Info").textContent = "å°šæœªé¸æ“‡ MP4";
      return;
    }
    // reset
    try{ if(state.video?.url) URL.revokeObjectURL(state.video.url); }catch{}
    state.video = {
      name: f.name,
      file: f,
      url: URL.createObjectURL(f),
      duration: 0,
      width: 0,
      height: 0
    };
    el("mp4Info").textContent = `${f.name}`;
    v.src = state.video.url;

    // wait metadata
    await new Promise((resolve, reject)=>{
      const onLoaded = ()=>{
        v.removeEventListener("loadedmetadata", onLoaded);
        v.removeEventListener("error", onErr);
        resolve();
      };
      const onErr = ()=>{
        v.removeEventListener("loadedmetadata", onLoaded);
        v.removeEventListener("error", onErr);
        reject(new Error("MP4 è®€å–å¤±æ•—ï¼ˆç€è¦½å™¨ç„¡æ³•è§£ç¢¼æ­¤å½±ç‰‡ï¼‰"));
      };
      v.addEventListener("loadedmetadata", onLoaded, {once:true});
      v.addEventListener("error", onErr, {once:true});
    }).catch(err=>{
      alert(err.message || String(err));
    });

    state.video.duration = v.duration || 0;
    state.video.width = v.videoWidth || 0;
    state.video.height = v.videoHeight || 0;
  });
el("srtInput").addEventListener("change", async (e)=>{
    const f = (e.target.files || [])[0];
    if(!f){
      state.srtText = "";
      el("srtInfo").textContent = "å°šæœªé¸æ“‡ SRT";
      return;
    }
    state.srtText = await f.text();
    el("srtInfo").textContent = `å·²åŒ¯å…¥ï¼š${f.name}`;
    setStatus("å·²åŒ¯å…¥ SRT");
  });

  el("styleSelect").addEventListener("change", ()=>{
    el("customStyleWrap").style.display = (el("styleSelect").value === "E") ? "block" : "none";
    if(state.shots.length) renderCards();
  });
  el("customStyle").addEventListener("input", ()=>{
    if(state.shots.length) renderCards();
  });
  el("globalSuffix").addEventListener("input", ()=>{
    if(state.shots.length) renderCards();
  });

  el("globalSfx").addEventListener("input", ()=>{
    if(state.shots.length) renderCards();
  });
  el("globalMusic").addEventListener("input", ()=>{
    if(state.shots.length) renderCards();
  });

  el("modeSelect").addEventListener("change", ()=>{
    updateTopMeta();
    updateKlingCount();
    updateFilterHint();
    if(state.shots.length){
      const cfg = getModeConfig();
      state.shots.forEach(s=>{
        s.mode = cfg.mode;
        s.generate_sec = cfg.generateSec;
        s.target_sec = cfg.targetSec;
        s.stretch_factor = cfg.stretchFactor;
      });
      renderCards();
    }
  });

  // âœ… å…¨åŸŸå¼·åº¦æ»‘æ¡¿
  el("globalIntensity").addEventListener("input", ()=>{
    const v = parseFloat(el("globalIntensity").value || "1") || 1;
    el("globalIntensityVal").textContent = v.toFixed(2);
    if(state.shots.length) renderCards();
  });
  el("globalIntensityVal").textContent = (parseFloat(el("globalIntensity").value||"1")||1).toFixed(2);

  el("buildBtn").addEventListener("click", buildShots);
  el("copyJsonBtn").addEventListener("click", copyJson);
  el("downloadJsonBtn").addEventListener("click", downloadJson);
  el("exportOk2ZipBtn").addEventListener("click", exportOk2Zip);
  updateExportButtons();

  el("btnPickNear10").addEventListener("click", ()=>{
    if(!state.shots.length){ alert("è«‹å…ˆç”¢ç”Ÿåˆ†é¡"); return; }
    const tol = Math.max(0, parseFloat(el("near10Tol").value || "0.6"));
    let picked = 0;
    state.shots.forEach(s=>{
      const d = (s.end - s.start);
      const ok = Math.abs(d - 10.0) <= tol;
      s.use_kling = ok;
      if(ok) picked++;
    });
    updateKlingCount();
    renderCards();
    alert(`å·²å‹¾é¸ â‰ˆ10ç§’ æ®µï¼š${picked} æ®µï¼ˆå®¹å¿Â±${tol}sï¼‰`);
  });



  el("applyDefaultBtn").addEventListener("click", ()=>{
    if(!state.shots.length){ alert("è«‹å…ˆç”¢ç”Ÿåˆ†é¡"); return; }
    state.shots.forEach(s=>{
      s.userEditedMotion = false;         // âœ… å› auto
      s.userEditedSfx = false;
      s.userEditedMusic = false;
      s.motionLevel = detectMotionLevel(s.text);
      s.cameraPrompt = defaultCameraPrompt();
      s.intensity = 1.0;
    });
    renderCards();
    alert("å·²é‡ç½®ï¼šå‹•æ…‹å› Auto + é‹é¡é‡ç½® + æœ¬æ®µå¼·åº¦=1.0");
  });

  el("clearBtn").addEventListener("click", ()=>{
    state.images.forEach(x=>{ try{URL.revokeObjectURL(x.url)}catch{} });
    state.images = [];
    state.srtText = "";
    state.cues = [];
    state.chunks = [];
    state.shots = [];
    state.baseName = "";
    state.viewFilter = "all";

    el("mp4Input").value = "";
    el("srtInput").value = "";
    el("mp4Info").textContent = "å°šæœªé¸æ“‡ MP4";
    el("srtInfo").textContent = "å°šæœªé¸æ“‡ SRT";
    el("cards").innerHTML = "";
    setStatus("å°šæœªç”¢ç”Ÿ");
    updateTopMeta();
    updateKlingCount();
    updateFilterHint();
    el("copyJsonBtn").disabled = true;
    el("downloadJsonBtn").disabled = true;
    el("exportOk2ZipBtn").disabled = true;
  });


  // ===== Kling selection tools =====
  const _selNone = document.getElementById("selectNoneBtn");
  const _selAll = document.getElementById("selectAllBtn");
  const _sel6 = document.getElementById("selectKey6Btn");
  const _sel4 = document.getElementById("selectKey4Btn");

  if(_selNone) _selNone.addEventListener("click", ()=>setAllKling(false));
  if(_selAll) _selAll.addEventListener("click", ()=>setAllKling(true));
  if(_sel6) _sel6.addEventListener("click", ()=>applyRecommended([5,6,18,19,23,25]));
  if(_sel4) _sel4.addEventListener("click", ()=>applyRecommended([5,6,23,25]));

  // ===== Filter buttons (in case onclick is stripped by sanitizer) =====
  const _fAll = document.getElementById("filterAllBtn");
  const _fK = document.getElementById("filterKlingBtn");
  const _fS = document.getElementById("filterStillBtn");
  if(_fAll) _fAll.addEventListener("click", ()=>setViewFilter("all"));
  if(_fK) _fK.addEventListener("click", ()=>setViewFilter("kling"));
  if(_fS) _fS.addEventListener("click", ()=>setViewFilter("still"));

  // init
  updateTopMeta();
  updateKlingCount();
  updateFilterHint();
  setStatus("å°šæœªç”¢ç”Ÿ");

  

// ===== UX fixes: prevent Enter in inputs from jumping / triggering actions =====
document.addEventListener('keydown', (e) => {
  const t = e.target;
  if (!t) return;
  const tag = (t.tagName || '').toLowerCase();
  if (e.key === 'Enter' && (tag === 'input' || tag === 'textarea' || tag === 'select')) {
    e.preventDefault();
    e.stopPropagation();
    return false;
  }
}, true);

// Preserve scroll position around rerenders (some browsers may scroll to top on DOM rebuild)
const __origRenderShots = window.renderShots;
if (typeof __origRenderShots === 'function') {
  window.renderShots = (...args) => {
    const y = window.scrollY;
    const activeId = document.activeElement && document.activeElement.id;
    const r = __origRenderShots(...args);
    requestAnimationFrame(() => {
      window.scrollTo({ top: y, left: 0, behavior: 'auto' });
      if (activeId) {
        const el = document.getElementById(activeId);
        if (el) el.focus({ preventScroll: true });
      }
    });
    return r;
  };
}


  // ===== OK2 Export (restored) =====
  async function exportOk2Zip(){
    if(typeof JSZip === "undefined"){
      alert("ç¼ºå°‘ JSZipï¼ˆCDN ä¸‹è¼‰å¤±æ•—ï¼‰ã€‚è«‹ç¢ºèªç¶²è·¯å¯ç”¨ã€‚");
      return;
    }
    const btn = el("exportOk2ZipBtn");
    btn.disabled = true;
    const oldTxt = btn.textContent;
    btn.textContent = "æ‰“åŒ…ä¸­...";

    try{
      const zip = new JSZip();

      const baseName = (state.baseName || safeBaseFromImages(state.images) || "story");
      const root = zip.folder(baseName);
      // files: manifest + overrides
      const manifest = buildOk2Manifest();
      const overrides = buildOverridesAll();
      root.file("manifest.json", JSON.stringify(manifest, null, 2));
      root.file("overrides.json", JSON.stringify(overrides, null, 2));
      // === include frames_srt jpgs (cut from source MP4) ===
      // path: <base>/out_assets/seg_0001.jpg..
      const dataURLToUint8 = (dataURL) => {
        const m = String(dataURL || "").match(/^data:([^;]+);base64,(.+)$/);
        if (!m) throw new Error("bad dataURL");
        const b64 = m[2];
        const bin = atob(b64);
        const u8 = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
        return u8;
      };

      const folderFrames = root.folder("out_assets");
if (Array.isArray(state.images) && state.images.length) {
        for (let i = 0; i < state.images.length; i++) {
          const it = state.images[i];
          const name = `seg_${String(i + 1).padStart(4, "0")}.jpg`;
          try {
            folderFrames.file(name, dataURLToUint8(it.url), { binary: true });
          } catch (e) {
            console.warn("skip frame", i, e);
          }
        }
      }
      // âœ… ä½ è¦çš„è·¯å¾‘ï¼šstory/remp3_output/<base>/
      const folder = root.folder("remp3_output");
// generate/reuse mp3 per segment (B: only update changed)
      let done = 0;
      const total = state.shots.length;

      for(const seg of state.shots){
        const text = (seg.text || "").trim();
        if(!text){
          // no text â†’ skip mp3 (still create placeholder? here skip)
          done++;
          btn.textContent = `æ‰“åŒ…ä¸­... ${done}/${total}ï¼ˆè·³éç©ºæ®µ ${seg.id}ï¼‰`;
          continue;
        }
        btn.textContent = `ç”¢ç”Ÿ/é‡ç”¨ mp3... ${done+1}/${total}`;
        const { blob, reused } = await getOrGenMp3ForSegment(seg);
        folder.file(`${baseName}_${seg.id}.mp3`, blob);
        done++;
        btn.textContent = `æ‰“åŒ…ä¸­... ${done}/${total}` + (reused ? "ï¼ˆé‡ç”¨ï¼‰" : "");
      }

      // generate zip
      btn.textContent = "è¼¸å‡º ZIP...";
      const out = await zip.generateAsync({ type: "blob" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(out);
      a.download = `${baseName}_OK2_PACKAGE.zip`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1500);

      // refresh cards to reflect cleared dirty tags
      renderCards();
      updateExportButtons();
    }catch(e){
      alert(String(e));
      console.error(e);
    }finally{
      btn.disabled = false;
      btn.textContent = oldTxt;
    }
  }

          function applyVoiceToRole(role, voiceCfg){
  if(!role) return;
  for(const s of (state.shots||[])){
    if((s.role||"narration") === role){
      s.voiceCfg = { ...voiceCfg };
      s.voiceDirty = true;
    }
  }
}

</script>
</body>
</html>









<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>SRT 工具｜生圖提示辭 / 運鏡提示辭 / MP3（TTS）</title>
<style>
  :root{
    --bg:#0b1220;--panel:#0f1b33;--panel2:#0c172d;--text:#e8eefc;--muted:#9fb1d1;
    --line:#1b2b4b;--btn:#1f6feb;--btn2:#12264d;--danger:#ff5d5d;--ok:#22c55e;
    --radius:14px;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans TC,Arial; background:var(--bg); color:var(--text);}
  header{padding:14px 16px;border-bottom:1px solid var(--line);background:linear-gradient(180deg,#0e1a31,#0b1220)}
  header .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  h1{margin:0;font-size:16px;font-weight:700;letter-spacing:.2px}
  .hint{color:var(--muted);font-size:12px}
  .wrap{padding:16px;max-width:1200px;margin:0 auto}
  .card{background:var(--panel);border:1px solid var(--line);border-radius:var(--radius);padding:14px}
  .grid{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:980px){ .grid{grid-template-columns:1.1fr .9fr} }
  label{display:block;color:var(--muted);font-size:12px;margin-bottom:6px}
  input[type="text"], input[type="number"], select, textarea{
    width:100%;background:var(--panel2);border:1px solid var(--line);color:var(--text);
    border-radius:12px;padding:10px 12px;outline:none;
  }
  textarea{min-height:160px;resize:vertical}
  .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end}
  .controls .field{min-width:180px;flex:1}
  .controls .field.small{min-width:140px;flex:0 0 140px}
  .controls .field.mid{min-width:220px;flex:1.2}
  .btn{
    border:1px solid transparent;border-radius:12px;padding:10px 14px;font-weight:700;
    background:var(--btn);color:white;cursor:pointer;user-select:none;
  }
  .btn.secondary{background:var(--btn2);border-color:var(--line);color:var(--text)}
  .btn.ghost{background:transparent;border-color:var(--line);color:var(--text)}
  .btn:disabled{opacity:.45;cursor:not-allowed}
  .status{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .pill{font-size:12px;color:var(--muted);border:1px solid var(--line);background:rgba(0,0,0,.15);padding:6px 10px;border-radius:999px}
  .pill.ok{border-color:rgba(34,197,94,.35);color:#bbf7d0}
  .pill.bad{border-color:rgba(255,93,93,.35);color:#fecaca}
  table{width:100%;border-collapse:collapse;border:1px solid var(--line);border-radius:12px;overflow:hidden}
  th,td{border-bottom:1px solid var(--line);padding:10px 10px;vertical-align:top}
  th{background:rgba(255,255,255,.03);color:var(--muted);font-size:12px;text-align:left}
  td{font-size:13px;line-height:1.25}
  tr:hover{background:rgba(31,111,235,.08)}
  tr.selected{background:rgba(34,197,94,.10)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .twoCol{display:grid;grid-template-columns:1fr;gap:16px}
  .footerNote{color:var(--muted);font-size:12px;line-height:1.5}
  .copyRow{display:flex;gap:10px;align-items:stretch;flex-direction:column}
  .copyRow button{white-space:nowrap;align-self:flex-end}
  .toast{position:fixed;left:50%;bottom:16px;transform:translateX(-50%);
    background:rgba(15,27,51,.96);border:1px solid var(--line);padding:10px 12px;border-radius:999px;
    color:var(--text);font-size:13px;opacity:0;pointer-events:none;transition:opacity .18s ease;
  }
  .toast.show{opacity:1}
</style>
</head>
<body>
<header>
  <div class="row">
    <h1>SRT → 依句生成：生圖提示辭 / 運鏡提示辭（可下載 JSON / CSV）＋ MP3（TTS）</h1>
    <span class="pill mono">規格：短檔名 + 序號（例：lion_mouse_001）</span>
  </div>
  <div class="hint">提示：先解析生成，再點表格任一列 → 按哪列就處理哪列（不自動選取/不自動填入）。</div>
</header>

<div class="wrap">
  <div class="grid">
    <div class="card">
      <div class="controls">
        <div class="field mid">
          <label>1) 上傳 SRT（會自動識別檔名）</label>
          <input id="srtFile" type="file" accept=".srt,.txt"/>
        </div>
        <div class="field">
          <label>短檔名（可改）</label>
          <input id="shortName" type="text" placeholder="例如：lion_mouse"/>
          <div class="hint" style="margin-top:6px; display:flex; gap:10px; align-items:center;">
            <label style="display:flex;align-items:center;gap:6px;">
              <input type="checkbox" id="lockShortName"/>
              <span>鎖短檔名（換 SRT 不自動改）</span>
            </label>
          </div>
        </div>
        <div class="field small">
          <label>每張圖使用幾句英文（1–3）</label>
          <select id="sentPerSlide">
            <option value="1">1 句</option>
            <option value="2" selected>2 句</option>
            <option value="3">3 句</option>
          </select>
        </div>
        <button id="btnParse" class="btn">2) 解析 + 生成提示辭</button>
        <button id="btnJson" class="btn secondary" disabled>下載 JSON</button>
        <button id="btnCsv" class="btn secondary" disabled>下載 CSV</button>
      </div>

      <!-- Era + Reference images -->
      <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end;">
        <div style="min-width:220px; flex:1;">
          <div style="font-size:12px; opacity:.9; margin-bottom:6px;">世界觀（可手動切換）</div>
          <select id="eraSelect" style="width:100%;">
            <option value="auto" selected>自動（依內容推測）</option>
            <option value="historical_ancient_china">古代中國／歷史敘事（禁止現代）</option>
            <option value="modern_realistic">現代寫實（禁止古代）</option>
            <option value="storybook_fantasy">童話寫實（中性、不現代科技）</option>
          </select>
          <div style="font-size:11px; opacity:.65; margin-top:6px;">提示：若你有混合素材，請改手動選。</div>
        </div>

        <div style="min-width:260px; flex:1.2;">
          <div style="font-size:12px; opacity:.9; margin-bottom:6px;">參考圖（1–3 張，用來鎖風格／年代）</div>
          <div style="margin-top:8px;">
            <div style="font-size:12px; opacity:.9; margin-bottom:4px;">Reference 使用模式</div>
            <select id="refModeSelect" style="width:100%;">
              <option value="global">Global（全片共用）</option>
              <option value="beats" selected>By Beats（起承轉合自動分配）</option>
            </select>
          </div>

          <input id="refImages" type="file" accept="image/*" multiple style="width:100%; padding:8px;" />
          <div style="display:flex; gap:10px; align-items:center; margin-top:8px; flex-wrap:wrap;">
            <label style="display:flex;align-items:center;gap:6px; font-size:12px; opacity:.9;">
              <input type="checkbox" id="lockRefThisFile"/>
              <span>一鍵鎖本片參考（不殘留到下一支）</span>
            </label>
            <button id="btnClearRef" type="button" class="btn ghost" style="padding:8px 10px;">一鍵清空參考</button>
          </div>
          <div id="refImagesHint" style="font-size:11px; opacity:.75; margin-top:6px;">（Story Mode：不送參考圖進模型，只鎖風格）未選擇參考圖</div>
          <div style="margin-top:10px; padding:10px; border:1px solid rgba(255,255,255,.08); border-radius:12px;">
            <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:8px;">
              <label style="display:flex; gap:8px; align-items:center; font-size:12px; margin:0;">
                <input type="checkbox" id="charLock" checked>
                <span>鎖角色（本片一致）</span>
              </label>
              <label style="display:flex; gap:8px; align-items:center; font-size:12px; margin:0;">
                <input type="checkbox" id="forceChineseFace">
                <span>強制中國臉（避免歐美混臉）</span>
              </label>
              <button id="btnClearChar" type="button" class="btn ghost" style="padding:8px 10px;">一鍵清空角色</button>
            </div>
            <div style="display:grid; grid-template-columns:1fr; gap:8px;">
              <div>
                <div style="font-size:12px; opacity:.85; margin-bottom:4px;">本片角色錨定（建議 1–3 行，描述「人物身份＋年代服飾＋髮型鬍子＋氣質」；不要寫鏡頭）</div>
                <textarea id="charAnchor" rows="3" placeholder="例：主角：中國古代書生，東亞臉型，黑髮髮髻，寬袖長袍，沉穩溫和。配角：村民、官差皆為東亞面孔與古代布衣。"></textarea>
              </div>
              <div>
                <div style="font-size:12px; opacity:.85; margin-bottom:4px;">本片避免項（可選；用逗號）</div>
                <input id="negExtra" placeholder="例：cartoon, anime, modern city, western clothing">
              </div>
            </div>
            <div style="font-size:11px; opacity:.7; margin-top:6px;">
              說明：這裡只影響「本片」的 photo_prompt，不會殘留到下一支；你換 SRT 會自動清空（除非你勾選鎖短檔名）。
            </div>
          </div>

        </div>
      </div>

      <div style="height:10px"></div>

      <div class="controls">
        <div class="field mid">
          <label>MP3（TTS）— 走 Supabase Edge Function（tts-mp3 / Azure）</label>
          <div class="hint">不需要輸入 OpenAI Key。會用你已存在的 tts-mp3：/functions/v1/tts-mp3</div>
        </div>
        <div class="field">
          <label>Voice（Azure）</label>
          <select id="ttsVoice">
            <option value="en-US-AnaNeural">en-US-AnaNeural</option>
            <option value="en-US-AriaNeural" selected>en-US-AriaNeural（女）</option>
            <option value="en-US-JennyNeural">en-US-JennyNeural（女）</option>
            <option value="en-US-GuyNeural">en-US-GuyNeural（男）</option>
            <option value="en-AU-NatashaNeural">en-AU-NatashaNeural</option>
          </select>
        </div>
        <div class="field small">
          <label>rate（例：0% / -10% / +10%）</label>
          <input id="ttsRate" type="text" placeholder="0%"/>
        </div>
        <div class="field small">
          <label>pitch（例：0% / -5% / +5%）</label>
          <input id="ttsPitch" type="text" placeholder="0%"/>
        </div>

        <div class="field small">
          <label>圖片比例（對齊 CapCut）</label>
          <select id="imgRatio">
            <option value="9:16" selected>9:16 直式（Shorts / Reels）</option>
            <option value="16:9">16:9 橫式（YouTube）</option>
            <option value="1:1">1:1 方形</option>
          </select>
        </div>

        <button id="btnMp3One" class="btn secondary" disabled>生 MP3（選取列）</button>
        <button id="btnImgOne" class="btn secondary" disabled>生圖（選取列）</button>

        <div class="field small">
          <label>批次 N</label>
          <input id="batchN" type="number" min="1" step="1" value="10"/>
        </div>
        <button id="btnMp3Batch" class="btn secondary" disabled>批次生 MP3（前 N 列）</button>
        <button id="btnImgBatch" class="btn secondary" disabled>批次生圖（前 N 列）</button>
      </div>

      <div style="height:12px"></div>

      <div class="status">
        <span id="pillFile" class="pill">未選擇檔案</span>
        <span id="pillRows" class="pill">未解析</span>
        <span id="pillSel" class="pill">未選取列</span>
        <span class="pill mono">完成：<span id="statSents">0</span> 句 → <span id="statSlides">0</span> 張</span>
      </div>

      <div style="height:12px"></div>

      <div style="overflow:auto;max-height:460px;border-radius:12px">
        <table id="tbl">
          <thead>
            <tr>
              <th style="width:160px">ID</th>
              <th style="width:160px">時間</th>
              <th>英文句（對齊）</th>
              <th>生圖提示辭（photo_prompt）</th>
              <th>運鏡提示辭（camera_prompt）</th>
            </tr>
          </thead>
          <tbody id="tbody">
            <tr><td colspan="5" class="footerNote">尚未解析。請先上傳 SRT → 按「解析 + 生成提示辭」。</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <div class="twoCol">
        <div>
          <label>快速複製：單張生圖提示辭（photo_prompt）</label>
          <div class="copyRow">
            <textarea id="quickPhoto" placeholder="點表格任一列，這裡就會出現 photo_prompt"></textarea>
            <button id="btnCopyPhoto" class="btn secondary" disabled>複製</button>
          </div>
          <div class="footerNote">目的：你可以直接 Ctrl+V 貼到 GPT 生單張圖。ID 在表格第一欄。</div>
        </div>
        <div>
          <label>快速複製：單張運鏡提示辭（camera_prompt）</label>
          <div class="copyRow">
            <textarea id="quickCam" placeholder="點表格任一列，這裡就會出現 camera_prompt"></textarea>
            <button id="btnCopyCam" class="btn secondary" disabled>複製</button>
          </div>
          <div class="footerNote">運鏡可貼到你後續的動畫/剪輯工具或當作提示詞。</div>
        </div>
      </div>

      <div style="height:12px"></div>
      <div class="footerNote">
        <b>注意：</b><br/>
        1) MP3 由你現有的 <span class="mono">tts-mp3</span> (Azure) 產生，檔名固定 <span class="mono">ID.mp3</span>。<br/>
        2) 批次下載會逐檔下載（瀏覽器可能會擋多檔下載，請允許）。<br/>
        3) 若你看到舊畫面或舊 JS，請用 <span class="mono">Ctrl+F5</span> 強制重整（或清快取）。
      </div>
    </div>
  </div>
</div>

<div id="toast" class="toast">已複製</div>

<script>
(() => {
  "use strict";

  // === endpoints ===
  const SUPA_TTS_MP3_URL = "https://jeajrwpmrgczimmrflxo.supabase.co/functions/v1/tts-mp3";
  const IMG_ONE_URL      = "https://jeajrwpmrgczimmrflxo.supabase.co/functions/v1/img-one";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImplYWpyd3BtcmdjemltbXJmbHhvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA3MTg5MzksImV4cCI6MjA3NjI5NDkzOX0.3iFXdHH0JEuk177_R4TGFJmOxYK9V8XctON6rDe7-Do";

  const el = (id) => document.getElementById(id);

  // inputs
  const srtFile = el("srtFile");
  const shortName = el("shortName");
  const lockShortName = el("lockShortName");
  const sentPerSlide = el("sentPerSlide");
  const btnParse = el("btnParse");
  const btnJson = el("btnJson");
  const btnCsv = el("btnCsv");

  const eraSelect = el("eraSelect");
  const refModeSelect = el("refModeSelect");
  const refImages = el("refImages");
  const refImagesHint = el("refImagesHint");
  const lockRefThisFile = el("lockRefThisFile");
  const btnClearRef = el("btnClearRef");

  const charLock = el("charLock");
  const forceChineseFace = el("forceChineseFace");
  const btnClearChar = el("btnClearChar");
  const charAnchor = el("charAnchor");
  const negExtra = el("negExtra");


  const ttsVoice = el("ttsVoice");
  const ttsRate  = el("ttsRate");
  const ttsPitch = el("ttsPitch");
  const imgRatio = el("imgRatio");
  const batchN = el("batchN");

  const btnMp3One = el("btnMp3One");
  const btnImgOne = el("btnImgOne");
  const btnMp3Batch = el("btnMp3Batch");
  const btnImgBatch = el("btnImgBatch");

  // ui
  const pillFile = el("pillFile");
  const pillRows = el("pillRows");
  const pillSel = el("pillSel");
  const statSents = el("statSents");
  const statSlides = el("statSlides");
  const tbody = el("tbody");
  const quickPhoto = el("quickPhoto");
  const quickCam = el("quickCam");
  const btnCopyPhoto = el("btnCopyPhoto");
  const btnCopyCam = el("btnCopyCam");
  const toast = el("toast");

  // sizes
  const IMG_SIZE_BY_RATIO = {"9:16":"1024x1536","16:9":"1536x1024","1:1":"1024x1024"};
  let imgSize = IMG_SIZE_BY_RATIO[imgRatio?.value] || "1024x1536";
  imgRatio?.addEventListener("change", ()=>{ imgSize = IMG_SIZE_BY_RATIO[imgRatio.value] || "1024x1536"; });

  // state
  /** @type {Array<{id:string,start:string,end:string,english:string,photo_prompt:string,camera_prompt:string,source_filename:string}>} */
  let rows = [];
  /** @type {{id:string,start:string,end:string,english:string,photo_prompt:string,camera_prompt:string,source_filename:string}|null} */
  let selectedRow = null;
  let selectedRowIndex = -1;

  // per-file guard: if SRT changes, auto clear table + (optionally) reference
  let currentSrtKey = null;
  let lastLockedRefKey = null; // remember which SRT had "lock ref"

  const fileKey = (f) => `${f.name}|${f.size}|${f.lastModified}`;

  // helpers
  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add("show");
    setTimeout(()=>toast.classList.remove("show"), 900);
  }

  function sanitizeShortName(name){
    return (name || "")
      .trim()
      .toLowerCase()
      .replace(/\.[a-z0-9]+$/i, "")
      .replace(/[^a-z0-9]+/g, "_")
      .replace(/^_+|_+$/g, "")
      .slice(0, 40) || "srt";
  }

  function pad3(n){ return ("000"+String(n)).slice(-3); }

  function updateRefHint(){
    const files = Array.from(refImages?.files || []);
    refImagesHint.textContent = files.length
      ? (`已選擇 ${files.length} 張參考圖：` + files.map(f=>f.name).join("、"))
      : "（Story Mode：不送參考圖進模型，只鎖風格）未選擇參考圖";
  }

  function clearReferenceUI({forceUnlock=false} = {}){
    if (refImages) refImages.value = "";
    if (forceUnlock && lockRefThisFile) lockRefThisFile.checked = false;
    updateRefHint();
  }

  function resetTableUI(){
    rows = [];
    selectedRow = null;
    selectedRowIndex = -1;
    tbody.innerHTML = `<tr><td colspan="5" class="footerNote">尚未解析。請先上傳 SRT → 按「解析 + 生成提示辭」。</td></tr>`;
    statSents.textContent = "0";
    statSlides.textContent = "0";
    quickPhoto.value = "";
    quickCam.value = "";
    refreshButtons();
  }

  function refreshButtons(){
    const hasRows = rows.length > 0;
    btnJson.disabled = !hasRows;
    btnCsv.disabled = !hasRows;

    const hasSel = !!selectedRow;
    btnMp3One.disabled = !hasSel;
    btnImgOne.disabled = !hasSel;

    btnMp3Batch.disabled = !hasRows;
    btnImgBatch.disabled = !hasRows;

    btnCopyPhoto.disabled = !hasSel;
    btnCopyCam.disabled = !hasSel;

    pillRows.textContent = hasRows ? `已解析：${rows.length} 列` : "未解析";
    pillRows.className = "pill" + (hasRows ? " ok" : "");
    pillSel.textContent = hasSel ? `已選取：${selectedRow.id}` : "未選取列";
    pillSel.className = "pill" + (hasSel ? " ok" : "");
  }

  function downloadBlob(blob, filename){
    const a = document.createElement("a");
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1500);
  }

  function downloadText(text, filename, mime="application/json"){
    downloadBlob(new Blob([text], {type:mime}), filename);
  }

  function csvEscape(v){
    const s = String(v ?? "");
    return /[",\n\r]/.test(s) ? '"' + s.replaceAll('"','""') + '"' : s;
  }

  // --- SRT parse ---
  function splitIntoSentences(s){
    const t = (s||"").replace(/\s+/g," ").trim();
    if (!t) return [];
    const parts = [];
    let buf = "";
    for (let i=0;i<t.length;i++){
      const ch = t[i];
      buf += ch;
      if (/[.!?。！？]/.test(ch)){
        parts.push(buf.trim());
        buf = "";
      }
    }
    if (buf.trim()) parts.push(buf.trim());
    return parts.length ? parts : [t];
  }

  function parseSrt(srtText){
    const text = (srtText || "").replace(/\r/g, "");
    const blocks = text.split(/\n\n+/).map(b=>b.trim()).filter(Boolean);
    const items = [];
    for (const b of blocks){
      const lines = b.split("\n").map(x=>x.trim());
      if (lines.length < 2) continue;

      let timeLine = "";
      let startIdx = 0;
      if (/^\d+$/.test(lines[0])) { timeLine = lines[1] || ""; startIdx = 2; }
      else { timeLine = lines[0] || ""; startIdx = 1; }

      const m = timeLine.match(/(\d\d:\d\d:\d\d[,\.]\d\d\d)\s*-->\s*(\d\d:\d\d:\d\d[,\.]\d\d\d)/);
      if (!m) continue;

      const start = m[1].replace(".", ",");
      const end   = m[2].replace(".", ",");
      const caption = lines.slice(startIdx).join(" ").replace(/\s+/g," ").trim();
      if (!caption) continue;

      const sents = splitIntoSentences(caption);
      for (const sent of sents){
        const clean = sent.trim();
        if (clean) items.push({start, end, text: clean});
      }
    }
    return items;
  }

  async function readFileAsText(file){
    return await new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(String(fr.result || ""));
      fr.onerror = reject;
      fr.readAsText(file);
    });
  }

  // --- story mode era ---
  function bwInferEraFromText(text) {
    const t = (text || "").toLowerCase();
    const storyHints = ["lion","mouse","forest","fable","once upon a time","storybook","fairy","duckling","ugly duckling"];
    if (storyHints.some(k=>t.includes(k))) return "storybook_fantasy";
    const ancientHints = ["dynasty","ancient","imperial","court","kingdom","warlord","strategist","thatched","cottage"];
    if (ancientHints.some(k=>t.includes(k))) return "historical_ancient_china";
    return "storybook_fantasy";
  }

  function bwGetEraPrompt(eraKey) {
    if (eraKey === "historical_ancient_china") {
      return [
        "Pre-modern historical setting, ancient China inspired world",
        "No modern technology, no modern buildings, no contemporary clothing",
        "No modern vehicles, no modern signage, no smartphones"
      ];
    }
    if (eraKey === "modern_realistic") {
      return [
        "Modern contemporary setting, present-day environment",
        "No historical or ancient elements, no period costumes",
        "No ancient architecture, no traditional robes"
      ];
    }
    if (eraKey === "storybook_fantasy") {
      return [
        "Storybook realism with a timeless feel",
        "No modern technology, no contemporary branding",
        "Keep era consistent across all images"
      ];
    }
    return [];
  }

  function bwGetBeatStyleLine(rowIndex, totalRows){
    // In Story Mode we do NOT send reference images to model; we only keep a consistent style.
    // By Beats is still useful: you can choose 2-3 refs to guide different acts (opening / middle / ending).
    const files = Array.from(refImages?.files || []);
    const mode = refModeSelect?.value || "beats";
    if (!files.length) return "";
    if (mode === "global" || files.length === 1) {
      return "Follow the selected reference images for overall art style ONLY (do not lock a single protagonist).";
    }
    const n = files.length;
    const segment = Math.floor((rowIndex / Math.max(1,totalRows)) * n);
    const refIndex = Math.min(segment, n - 1);
    return `Follow reference style #${refIndex+1} (${files[refIndex].name}) for art style ONLY (do not lock a single protagonist).`;
  }

  
function makePhotoPrompt({ beatStyleLine, titleHint, english }) {
  const eraKey = (document.getElementById("eraSelect")?.value || "auto").trim();

  // B 版：本片角色錨定（不殘留到下一支；換 SRT 會清空）
  const charLock = !!document.getElementById("charLock")?.checked;
  const charAnchor = (document.getElementById("charAnchor")?.value || "").trim();
  const forceChineseFace = !!document.getElementById("forceChineseFace")?.checked;
  const negExtra = (document.getElementById("negExtra")?.value || "").trim();

  // 中國歷史人物：強化「東亞臉＋古代服飾」並避免歐美混臉
  const enforceChinese = forceChineseFace || eraKey === "ancient_china";

  const characterLockLine = charLock
    ? "Recurring characters must stay IDENTICAL across all images in this video (same face, same hairstyle, same clothing style)."
    : "";

  const characterAnchorLine = charAnchor
    ? `Character anchor (apply to ALL images in this video): ${charAnchor}`
    : "";

  const chineseFaceLine = enforceChinese
    ? "If humans appear: they MUST have East Asian (Chinese) facial features; traditional Chinese era clothing; no Western haircuts or modern accessories."
    : "";

  const avoidLineBase = enforceChinese
    ? "Avoid: European/Caucasian faces, Western facial structure, Western medieval/renaissance costumes, modern city, modern fashion, cartoon/anime."
    : "Avoid: cartoon/anime, modern city, modern fashion, brand logos, text overlays.";
  const avoidLine = negExtra ? `${avoidLineBase} Extra avoid: ${negExtra}.` : `${avoidLineBase}`;

  return [
    `Scene: ${english}`,
    titleHint,
    beatStyleLine,
    ...GLOBAL_STYLE,
    pickEraLine(eraKey),
    characterLockLine,
    characterAnchorLine,
    chineseFaceLine,
    avoidLine
  ].filter(Boolean).join("\n");
}

function makeCameraPrompt(english, idx){
    const moves = ["slow push-in","gentle lateral slide","static tripod with subtle breathing","slow pull-back reveal","soft handheld micro-movement"];
    const lenses = ["35mm","50mm","24mm wide","85mm portrait","70mm medium tele"];
    const pick = (arr) => arr[Math.abs(Number(idx||0)) % arr.length];
    return [
      `${pick(moves)}, ${pick(lenses)} lens`,
      "medium-wide to medium shot, natural lighting, soft focus pull",
      `match pacing to the line: "${english}"`
    ].join(", ");
  }

  function renderTable(){
    tbody.innerHTML = "";
    if (!rows.length){
      resetTableUI();
      return;
    }
    rows.forEach((r, i) => {
      const tr = document.createElement("tr");
      tr.dataset.id = r.id;

      const tdId = document.createElement("td"); tdId.className="mono"; tdId.textContent = r.id;
      const tdTime = document.createElement("td"); tdTime.className="mono"; tdTime.textContent = `${r.start} → ${r.end}`;
      const tdEn = document.createElement("td"); tdEn.textContent = r.english;
      const tdP = document.createElement("td"); tdP.textContent = r.photo_prompt;
      const tdC = document.createElement("td"); tdC.textContent = r.camera_prompt;

      tr.append(tdId, tdTime, tdEn, tdP, tdC);

      tr.addEventListener("click", () => {
        selectedRow = r;
        selectedRowIndex = i;
        for (const rowEl of tbody.querySelectorAll("tr")){
          rowEl.classList.toggle("selected", rowEl.dataset.id === r.id);
        }
        quickPhoto.value = r.photo_prompt;
        quickCam.value = r.camera_prompt;
        refreshButtons();
      });

      tbody.appendChild(tr);
    });

    // do not auto-select
    selectedRow = null;
    selectedRowIndex = -1;
    quickPhoto.value = "";
    quickCam.value = "";
    refreshButtons();
  }

  // --- Reference lock logic (per video) ---
  // rule:
  // - If lockRefThisFile is ON, refs are allowed for THIS SRT only.
  // - When you switch to another SRT: refs auto clear + lock checkbox auto off.
  // - If lockRefThisFile is OFF: refs are treated as "temporary"; switching SRT also clears.
  function onSrtSwitched(newKey){
    // Always clear table when switching SRT
    resetTableUI();

    // Always clear reference when switching SRT (so it never leaks)
    clearReferenceUI({forceUnlock:true});
    lastLockedRefKey = null;
    clearRefCache();

    // Always clear character anchor when switching SRT (so it never leaks)
    clearCharAnchorUI();

    // Also clear quick copy
    quickPhoto.value = "";
    quickCam.value = "";
  }

  // events
  refImages?.addEventListener("change", () => { updateRefHint(); });
  btnClearRef?.addEventListener("click", () => { clearReferenceUI({forceUnlock:false}); clearRefCache(); });

  function clearCharAnchorUI() {
    if (charAnchor) charAnchor.value = "";
    if (negExtra) negExtra.value = "";
    if (forceChineseFace) forceChineseFace.checked = false;
    if (charLock) charLock.checked = true;
  }

  if (btnClearChar) btnClearChar.addEventListener("click", () => {
    clearCharAnchorUI();
    toast("已清空角色錨定");
  });

  if (eraSelect && forceChineseFace) {
    eraSelect.addEventListener("change", () => {
      // 古代中國：預設打開「強制中國臉」，但你仍可手動關掉
      if (eraSelect.value === "ancient_china") {
        forceChineseFace.checked = true;
      }
    });
  }

  srtFile.addEventListener("change", () => {
    const f = srtFile.files && srtFile.files[0];
    if (!f){
      currentSrtKey = null;
      pillFile.textContent = "未選擇檔案";
      pillFile.className = "pill";
      onSrtSwitched(null);
      return;
    }
    const newKey = fileKey(f);
    window.__srtFileName = f.name;

    if (currentSrtKey && newKey !== currentSrtKey){
      onSrtSwitched(newKey);
    }
    currentSrtKey = newKey;

    const base = sanitizeShortName(f.name);
    if (!lockShortName?.checked){
      shortName.value = base;
    } else {
      if (!shortName.value.trim()) shortName.value = base;
    }

    pillFile.textContent = `已選：${f.name}`;
    pillFile.className = "pill ok";
  });

  btnParse.addEventListener("click", async () => {
    const f = srtFile.files && srtFile.files[0];
    if (!f){ alert("請先選擇 .srt 檔"); return; }

    btnParse.disabled = true;
    const oldText = btnParse.textContent;
    btnParse.textContent = "解析中…";

    try{
      const txt = await readFileAsText(f);
      const sents = parseSrt(txt);

      const per = Math.max(1, Math.min(3, Number(sentPerSlide.value || 1)));
      const sname = sanitizeShortName(shortName.value || f.name);
      const titleHint = sname.replaceAll("_"," ").trim();

      rows = [];
      selectedRow = null;
      selectedRowIndex = -1;

      statSents.textContent = String(sents.length);

      const totalSlides = Math.ceil(sents.length / per);
      statSlides.textContent = String(totalSlides);

      for (let i=0;i<totalSlides;i++){
        const chunk = sents.slice(i*per, i*per + per);
        if (!chunk.length) continue;

        const english = chunk.map(x=>x.text).join(" ").replace(/\s+/g," ").trim();
        const start = chunk[0].start;
        const end = chunk[chunk.length-1].end;

        const id = `${sname}_${pad3(i+1)}`;
        const photo_prompt = makePhotoPrompt(english, titleHint, i, i, totalSlides);
        const camera_prompt = makeCameraPrompt(english, i);

        rows.push({id,start,end,english,photo_prompt,camera_prompt,source_filename:f.name});
      }

      renderTable();
      refreshButtons();
    }catch(e){
      console.error(e);
      alert("解析失敗：請看 Console");
    }finally{
      btnParse.disabled = false;
      btnParse.textContent = oldText;
    }
  });

  btnJson.addEventListener("click", () => {
    if (!rows.length) return;
    const name = sanitizeShortName(shortName.value || "srt");
    downloadText(JSON.stringify(rows, null, 2), `${name}_prompts.json`, "application/json");
  });

  btnCsv.addEventListener("click", () => {
    if (!rows.length) return;
    const name = sanitizeShortName(shortName.value || "srt");
    const headers = ["id","start","end","english","photo_prompt","camera_prompt","source_filename"];
    const lines = [headers.join(",")];
    for (const r of rows){
      lines.push(headers.map(h=>csvEscape(r[h])).join(","));
    }
    downloadText(lines.join("\n"), `${name}_prompts.csv`, "text/csv;charset=utf-8");
  });

  btnCopyPhoto.addEventListener("click", async () => {
    if (!selectedRow) return;
    await navigator.clipboard.writeText(quickPhoto.value || "");
    showToast("已複製 photo_prompt");
  });
  btnCopyCam.addEventListener("click", async () => {
    if (!selectedRow) return;
    await navigator.clipboard.writeText(quickCam.value || "");
    showToast("已複製 camera_prompt");
  });

  async function ttsToMp3(row){
    const voice = ttsVoice.value || "en-US-AriaNeural";
    const rate = (ttsRate.value || "0%").trim() || "0%";
    const pitch = (ttsPitch.value || "0%").trim() || "0%";

    const resp = await fetch(SUPA_TTS_MP3_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "apikey": SUPABASE_ANON_KEY,
        "Authorization": "Bearer " + SUPABASE_ANON_KEY
      },
      body: JSON.stringify({ text: row.english, voice, rate, pitch })
    });

    if (!resp.ok){
      const t = await resp.text().catch(()=> "");
      alert(`TTS 失敗：${resp.status}\n${t}`);
      return;
    }
    const blob = await resp.blob();
    downloadBlob(blob, `${row.id}.mp3`);
  }

  async 
  // ===== Image generation (serial-safe) =====
  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

  // Cache ref images per current SRT (avoid re-reading files every row)
  let _refCacheKey = null;
  let _refCacheUrls = null;

  function clearRefCache(){
    _refCacheKey = null;
    _refCacheUrls = null;
  }

  async function readFilesAsDataUrls(fileList, maxN = 3){
    const files = Array.from(fileList || []).slice(0, maxN);
    const urls = [];
    for (const f of files){
      const url = await new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(String(fr.result || ""));
        fr.onerror = () => reject(fr.error || new Error("FileReader error"));
        fr.readAsDataURL(f);
      });
      urls.push(url);
    }
    return urls;
  }

  async function getRefImagesForSend(){
    // Only send reference images in By Beats mode (and only if user selected)
    const refInput = document.getElementById("refImages");
    if (!refInput) return null;

    // Tie cache to current SRT key (so switching SRT never leaks old reference)
    const key = currentSrtKey || "__none__";
    if (_refCacheKey === key && Array.isArray(_refCacheUrls)) return _refCacheUrls.length ? _refCacheUrls : null;

    const urls = await readFilesAsDataUrls(refInput.files, 3).catch(() => []);
    _refCacheKey = key;
    _refCacheUrls = urls;
    return urls.length ? urls : null;
  }

  async function imgOne(row, ref_images){
    // Returns: { ok:true, blob } OR { ok:false, status, code, message }
    const payload = { prompt: row.photo_prompt, size: imgSize };
    if (Array.isArray(ref_images) && ref_images.length) payload.ref_images = ref_images;

    // Retry for transient errors (429/5xx/network)
    const maxAttempts = 6;
    for (let attempt = 1; attempt <= maxAttempts; attempt++){
      let resp;
      try{
        resp = await fetch(IMG_ONE_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": "Bearer " + SUPABASE_ANON_KEY
          },
          body: JSON.stringify(payload)
        });
      }catch(e){
        // Network error
        const backoff = Math.min(15000, 700 * Math.pow(2, attempt-1));
        await sleep(backoff);
        continue;
      }

      if (resp.status === 429 || resp.status >= 500){
        const backoff = Math.min(20000, 700 * Math.pow(2, attempt-1));
        await sleep(backoff);
        continue;
      }

      if (!resp.ok){
        const raw = await resp.text().catch(() => "");
        // Try parse OpenAI style error
        let code = "";
        let msg = raw || ("HTTP " + resp.status);
        try{
          const j = JSON.parse(raw);
          const err = j?.detail?.error || j?.error || j?.detail || j;
          code = err?.code || err?.error?.code || "";
          msg = err?.message || err?.error?.message || msg;
        }catch(_){}

        return { ok:false, status: resp.status, code, message: msg };
      }

      const b64 = (await resp.text()).trim(); // edge function returns base64 or dataURL? (current impl returns base64)
      // If already dataURL, keep; else wrap
      const dataUrl = b64.startsWith("data:image") ? b64 : ("data:image/png;base64," + b64);
      const bytes = dataUrlToBytes(dataUrl);
      const blob = new Blob([bytes], { type: "image/png" });
      return { ok:true, blob };
    }

    return { ok:false, status: 0, code: "retry_exhausted", message: "Too many retries / network unstable." };
  }

  btnMp3One.addEventListener("click", async () => {
    if (!selectedRow) { alert("請先點選一列"); return; }
    btnMp3One.disabled = true;
    const old = btnMp3One.textContent;
    btnMp3One.textContent = "生成中…";
    try{ await ttsToMp3(selectedRow); }
    finally{ btnMp3One.disabled = false; btnMp3One.textContent = old; }
  });

  btnImgOne.addEventListener("click", async () => {
    if (!selectedRow) { alert("請先點選一列"); return; }
    btnImgOne.disabled = true;
    const old = btnImgOne.textContent;
    btnImgOne.textContent = "生成中…";
    try{ await imgOne(selectedRow); }
    finally{ btnImgOne.disabled = false; btnImgOne.textContent = old; }
  });

  btnMp3Batch.addEventListener("click", async () => {
    if (!rows.length) return;
    let n = Number(batchN.value || 10);
    if (!Number.isFinite(n) || n < 1) n = 10;
    n = Math.min(n, rows.length);

    if (!confirm(`將依序下載 ${n} 個 MP3（瀏覽器可能會詢問允許多檔下載）。要開始嗎？`)) return;

    btnMp3Batch.disabled = true;
    const old = btnMp3Batch.textContent;
    btnMp3Batch.textContent = `批次生成中（0/${n}）…`;
    try{
      for (let i=0;i<n;i++){
        btnMp3Batch.textContent = `批次生成中（${i+1}/${n}）…`;
        await ttsToMp3(rows[i]);
        await new Promise(r=>setTimeout(r, 250));
      }
      showToast(`批次完成：${n} 個 MP3`);
    }catch(e){
      console.error(e);
      alert("批次中斷：請看 Console");
    }finally{
      btnMp3Batch.disabled = false;
      btnMp3Batch.textContent = old;
    }
  });

  btnImgBatch.addEventListener("click", async () => {
    if (!rows.length) return;

    let n = Number(batchN.value || 10);
    if (!Number.isFinite(n) || n < 1) n = 10;
    n = Math.min(n, rows.length);

    if (!confirm(`將「逐張」依序生成並下載 ${n} 張圖片（遇到 429 會自動等待重試；遇到被系統阻擋的提示詞會跳過並繼續）。要開始嗎？`)) return;

    btnImgBatch.disabled = true;
    const old = btnImgBatch.textContent;
    const blocked = [];

    try{
      // Freeze reference images for THIS SRT run (so it won't change mid-batch)
      const ref_images = await getRefImagesForSend();

      for (let i=0;i<n;i++){
        btnImgBatch.textContent = `批次生成中（${i+1}/${n}）…`;
        const row = rows[i];

        const r = await imgOne(row, ref_images);
        if (!r?.ok){
          const msg = (r?.message || "unknown error").toString();

          // Hard stop cases
          if (msg.includes("billing_hard_limit") || msg.includes("Billing hard limit") || msg.includes("insufficient_quota")){
            alert("已達到帳務/額度限制（billing hard limit / quota）。請先到 Billing 補值或調整用量上限後再試。");
            break;
          }

          // Moderation blocked => skip but record
          if (r?.code === "moderation_blocked" || r?.code === "image_generation_user_error" || msg.includes("safety") || msg.includes("rejected by the safety system")){
            blocked.push({ id: row.id, reason: msg });
            // small cool down to avoid repeated blocks/429
            await sleep(600);
            continue;
          }

          // Other 4xx errors => stop (usually prompt / request format)
          alert(`生圖失敗（第 ${i+1} 張 / ID=${row.id}）
HTTP ${r?.status || ""} ${r?.code || ""}
${msg}`);
          break;
        }

        // success: download
        const filename = `${row.id}.png`;
        downloadBlob(r.blob, filename);

        // Gentle pacing
        await sleep(450);
      }

      if (blocked.length){
        console.warn("Blocked rows:", blocked);
        showToast(`完成（有跳過 ${blocked.length} 張被系統阻擋：請看 Console）`);
      }else{
        showToast(`批次完成：${n} 張圖片`);
      }
    }catch(e){
      console.error(e);
      alert("批次中斷：請看 Console");
    }finally{
      btnImgBatch.disabled = false;
      btnImgBatch.textContent = old;
    }
  });

  // init
  updateRefHint();
  refreshButtons();
})();
</script>
</body>
</html>

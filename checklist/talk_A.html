<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Talk A Adminï½œBookWide</title>
<style>
:root{
  --bg:#f4f6fb; --card:#fff; --ink:#0b1220; --muted:#5b667a; --line:#e6eaf0; --soft:#f6f8fb;
  --brand:#0b66ff; --brand2:#084fc6; --radius:24px; --shadow:0 12px 34px rgba(10,20,40,.10);
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans TC","PingFang TC","Microsoft JhengHei",sans-serif;background:var(--bg);color:var(--ink)}
a{color:inherit}
.wrap{max-width:980px;margin:0 auto;padding:12px 12px calc(14px + env(safe-area-inset-bottom));display:flex;flex-direction:column;gap:10px;min-height:100%}
.top{display:flex;align-items:center;gap:10px;padding:10px 12px;border:1px solid var(--line);border-radius:999px;background:rgba(255,255,255,.92);backdrop-filter:blur(10px);box-shadow:var(--shadow)}
.back{width:42px;height:42px;border-radius:999px;border:1px solid var(--line);background:#fff;display:grid;place-items:center;cursor:pointer}
.ttl{display:flex;flex-direction:column;gap:2px;min-width:0}
.ttl b{font-size:16px;line-height:1.1}
.ttl span{font-size:12px;color:var(--muted);line-height:1.1}
.topRight{margin-left:auto;display:flex;align-items:center;gap:8px;min-width:0}
.pill{display:flex;align-items:center;gap:8px;border:1px solid var(--line);border-radius:999px;padding:6px 10px;background:#fff;min-width:0}
.pill b{font-size:12px;color:var(--muted);white-space:nowrap}
.sel{border:0;outline:none;background:transparent;font-weight:800;color:var(--ink);font-size:13px;max-width:62vw}
.btn{border:1px solid var(--line);background:#fff;border-radius:999px;padding:10px 14px;font-weight:800;cursor:pointer}
.btn.primary{background:linear-gradient(180deg,var(--brand),var(--brand2));color:#fff;border-color:transparent;box-shadow:0 10px 22px rgba(11,102,255,.22)}
.card{border:1px solid var(--line);border-radius:var(--radius);background:var(--card);box-shadow:var(--shadow)}
.teacher{display:flex;gap:14px;align-items:center;padding:12px}
.avatar{width:76px;height:76px;border-radius:20px;overflow:hidden;border:1px solid var(--line);background:radial-gradient(circle at 30% 30%, #fff, #e9eef7)}
.avatar video,.avatar img{width:100%;height:100%;object-fit:cover;display:block}
.tInfo{min-width:0;flex:1}
.tInfo .sceneTitle{font-weight:900;font-size:18px;line-height:1.15;margin:0 0 4px}
.tInfo .meta{color:var(--muted);font-size:12px;line-height:1.2}
.aiLine{padding:14px 16px}
.aiEn{font-size:28px;font-weight:950;line-height:1.05;margin:0}
.aiZh{margin:6px 0 0;color:var(--muted);font-size:15px;line-height:1.15}
.controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;padding:10px 12px}
.mic{width:68px;height:68px;border-radius:999px;border:0;cursor:pointer;background:linear-gradient(180deg,var(--brand),var(--brand2));box-shadow:0 12px 26px rgba(11,102,255,.25);display:grid;place-items:center;color:#fff;font-size:26px}
.smallBtn{border:1px solid var(--line);background:#fff;border-radius:999px;padding:10px 14px;font-weight:900;cursor:pointer;display:flex;gap:8px;align-items:center}
.smallBtn:active{transform:translateY(1px)}
.reply{padding:14px 16px}
.rTop{display:flex;align-items:center;gap:8px}
.rTop h3{margin:0;font-size:18px}
.rTop .sp{margin-left:auto;display:flex;gap:8px}
.chip{border:1px solid var(--line);border-radius:999px;padding:8px 12px;background:#fff;font-weight:900;color:var(--muted)}
.q{margin:10px 0 6px;font-size:30px;font-weight:950;line-height:1.05}
.help{margin:0 0 10px;color:var(--muted);font-size:13px;line-height:1.25}
.inputRow{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.inp{flex:1;min-width:220px;border:1px solid var(--line);border-radius:16px;padding:14px 14px;font-size:18px;outline:none;background:#fff}
.actions{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px}
.fullBtn{flex:1;min-width:220px;border:0;border-radius:18px;padding:14px 16px;font-size:18px;font-weight:950;cursor:pointer}
.fullBtn.primary{background:linear-gradient(180deg,var(--brand),var(--brand2));color:#fff;box-shadow:0 12px 24px rgba(11,102,255,.22)}
.notice{padding:10px 12px;border:1px dashed var(--line);border-radius:16px;background:rgba(255,255,255,.7);color:var(--muted);font-size:12px;line-height:1.3}
.admin{padding:10px 12px;display:none}
.admin.show{display:block}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.file{border:1px solid var(--line);border-radius:14px;padding:10px;background:#fff}
.kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:12px;color:var(--muted)}
@media (max-width:520px){
  .aiEn{font-size:26px}
  .q{font-size:28px}
  .mic{width:64px;height:64px}
}
</style>
</head>
<body>
<div class="wrap" id="app">
  <div class="top">
    <button class="back" id="btnBack" aria-label="back">â†</button>
    <div class="ttl">
      <b>Talk Aï¼ˆç®¡ç†ï¼‰</b>
      <span>TTSï¼šBrowser SpeechSynthesis</span>
    </div>
    <div class="topRight">
      <div class="pill">
        <b id="wkTag">W?</b>
        <select class="sel" id="sceneSel"></select>
      </div>
      <button class="btn" id="btnReplay">é‡æ’­</button>
      <button class="btn" id="btnAdmin">Admin</button>
    </div>
  </div>

  <div class="card teacher">
    <div class="avatar" aria-label="teacher">
      <video id="teacherVideo" muted playsinline loop preload="metadata"></video>
    </div>
    <div class="tInfo">
      <div class="sceneTitle" id="sceneTitle">è¼‰å…¥ä¸­â€¦</div>
      <div class="meta" id="sceneMeta">è®€å– index.jsonâ€¦</div>
    </div>
  </div>

  <div class="card aiLine" id="aiCard" style="display:none">
    <p class="aiEn" id="aiEn"></p>
    <p class="aiZh" id="aiZh"></p>
  </div>

  <div class="card controls">
    <button class="mic" id="btnMic" title="èªéŸ³è¾¨è­˜">ğŸ¤</button>
    <button class="smallBtn" id="btnFocus">âŒ¨ï¸ è¼¸å…¥</button>
    <button class="smallBtn" id="btnSkip">è·³é</button>
    <button class="smallBtn" id="btnHint">æç¤º</button>
    <button class="smallBtn" id="btnSave">æ”¶è—</button>
    <button class="smallBtn" id="btnCloze">å¡«ç©ºå¼•å°</button>
  </div>

  <div class="card reply">
    <div class="rTop">
      <h3>ä½ çš„å›è¦†</h3>
      <div class="sp">
        <span class="chip" id="lvlChip">A1</span>
        <button class="btn" id="btnHide">éš±è—</button>
      </div>
    </div>
    <div class="q" id="qText">â€”</div>
    <p class="help" id="helpText">å°è©±æ¨¡å¼ï¼šAI å…ˆèªªä¸€å¥ï¼Œç­‰ä½ å›è¦†ï¼ˆèªéŸ³æˆ–è¼¸å…¥ï¼‰æ‰æœƒé€²ä¸‹ä¸€å¥ã€‚</p>
    <div class="inputRow">
      <input class="inp" id="userInput" placeholder="è¼¸å…¥å›è¦†â€¦"/>
    </div>
    <div class="actions">
      <button class="fullBtn primary" id="btnSubmit">âœ… é€å‡ºå¡«å¥½å¥</button>
      <button class="fullBtn" id="btnRetry">é‡ä¾†</button>
    </div>
    <div class="notice" id="errBox" style="display:none"></div>
  </div>

  <div class="card admin" id="adminBox">
    <div class="row" style="margin-bottom:8px">
      <div class="file">
        <div style="font-weight:900;margin-bottom:6px">é›¢ç·šæ¨¡å¼ï¼ˆfile://ï¼‰è«‹ä¸Šå‚³</div>
        <div class="row">
          <label class="file">index.json <input type="file" id="fileIndex" accept="application/json"></label>
          <label class="file">scene.json <input type="file" id="fileScene" accept="application/json"></label>
        </div>
      </div>
      <div class="file">
        <div style="font-weight:900;margin-bottom:6px">ç›®å‰æª”å</div>
        <div class="kbd" id="curJsonName">â€”</div>
      </div>
    </div>
    <div class="notice">æç¤ºï¼šä¸Šç·šæ™‚æœƒè‡ªå‹•è®€ <span class="kbd">/talk/index.json</span>ï¼ˆæˆ– <span class="kbd">../talk/index.json</span>ï¼‰èˆ‡ <span class="kbd">wxx.*.json</span>ï¼›æœ¬å€åªæ˜¯ç‚ºäº†è§£æ±º iPhone ç›´æ¥é–‹ä¸‹è¼‰æª”ï¼ˆfile://ï¼‰æ™‚ fetch å¤±æ•ˆã€‚</div>
  </div>
</div>


<script>
// ===== Global error guards (avoid Uncaught (in promise) Object) =====
window.addEventListener('unhandledrejection', (e) => {
  const reason = (e.reason instanceof Error) ? (e.reason.stack || e.reason.message) : safeStr(e.reason);
  console.error("UnhandledPromiseRejection:", e.reason);
  if (window.showErr) window.showErr("Promise Error: " + reason);
});
window.addEventListener('error', (e) => {
  console.error("RuntimeError:", e.message);
  if (window.showErr) window.showErr("Runtime Error: " + e.message);
});
function safeStr(v){ try{ return (typeof v==='string')?v:JSON.stringify(v); } catch(_){ return String(v); } }

(() => {
  'use strict';
  const $ = (id) => document.getElementById(id);
  const el = {
    sceneSel: $('sceneSel'),
    wkTag: $('wkTag'),
    btnReplay: $('btnReplay'),
    btnBack: $('btnBack'),
    btnMic: $('btnMic'),
    btnFocus: $('btnFocus'),
    btnSkip: $('btnSkip'),
    btnHint: $('btnHint'),
    btnSave: $('btnSave'),
    btnCloze: $('btnCloze'),
    qText: $('qText'),
    userInput: $('userInput'),
    btnSubmit: $('btnSubmit'),
    btnRetry: $('btnRetry'),
    aiEn: $('aiEn'),
    aiZh: $('aiZh'),
    sceneTitle: $('sceneTitle'),
    sceneMeta: $('sceneMeta'),
    lvlChip: $('lvlChip'),
    errBox: $('errBox'),
    teacherVideo: $('teacherVideo'),
    btnHide: $('btnHide'),
    adminBox: $('adminBox'),
    btnAdmin: $('btnAdmin'),
    fileIndex: $('fileIndex'),
    fileScene: $('fileScene'),
  };

  const state = {
    index: null,
    currentSceneId: null,
    scene: null,
    dialogue: [],
    aiIdx: -1,
    userIdx: -1,
    lastUserText: '',
    cloze: null, // {tmpl, answer, options[]}
  };

  // ===== Paths (Talk A in /checklist/ , data in /talk/) =====
  const indexURL = new URL('../talk/index.json', location.href);
  const sceneURL = (id) => new URL(`../talk/${id}.json`, location.href);

  // ===== UI helpers =====
  window.showErr = (msg) => {
    if (!el.errBox) return;
    el.errBox.style.display = 'block';
    el.errBox.textContent = msg || '';
  };
  function clearErr(){ if (el.errBox){ el.errBox.style.display='none'; el.errBox.textContent=''; } }
  function setLoading(en='Loading...'){
    if (el.aiEn) el.aiEn.textContent = en;
    if (el.aiZh) el.aiZh.textContent = 'è®€å– index.jsonâ€¦';
    if (el.sceneMeta) el.sceneMeta.textContent = 'è®€å– index.jsonâ€¦';
  }
  function setMeta(msg){ if(el.sceneMeta) el.sceneMeta.textContent = msg || ''; }
  function setTitle(msg){ if(el.sceneTitle) el.sceneTitle.textContent = msg || ''; }

  function pickLevelFromId(id){
    // deterministic A1/A2/B1 by week
    const m = String(id||'').match(/^w(\d+)/i);
    const w = m ? parseInt(m[1],10) : 1;
    if (w<=2) return 'A1';
    if (w<=4) return 'A2';
    return 'B1';
  }
  function getInitialSceneId(){
    const u = new URL(location.href);
    return u.searchParams.get('scene') || u.searchParams.get('id') || '';
  }
  function setQueryScene(id){
    const u = new URL(location.href);
    u.searchParams.set('scene', id);
    history.replaceState({}, '', u.toString());
  }

  function normalizeDialogueItem(d){
    // supports speaker/role and AI/USER
    const sp = (d.speaker || d.role || d.who || '').toString().toUpperCase();
    const isAI = sp === 'AI' || sp === 'BOT' || sp === 'ASSISTANT';
    const isUSER = sp === 'USER' || sp === 'YOU' || sp === 'STUDENT';
    const en = d.en || d.ai_en || d.text_en || d.text || '';
    const zh = d.zh || d.ai_zh || d.text_zh || '';
    const hint_en = d.hint_en || d.user_en || d.expected_reply || d.reply_en || '';
    const hint_zh = d.hint_zh || d.user_zh || d.reply_zh || '';
    return { raw:d, sp, isAI, isUSER, en, zh, hint_en, hint_zh };
  }

  function moveToNextPair(fromIdx){
    // find next AI at/after fromIdx, then next USER after that
    const arr = state.dialogue;
    let ai=-1, user=-1;
    for(let i=Math.max(0,fromIdx); i<arr.length; i++){
      if(arr[i].isAI){ ai=i; break; }
    }
    if(ai>=0){
      for(let i=ai+1; i<arr.length; i++){
        if(arr[i].isUSER){ user=i; break; }
        // tolerate multiple AI lines; user must be after AI
      }
    }
    state.aiIdx = ai;
    state.userIdx = user;
    return {ai,user};
  }

  function renderCurrent(){
    clearErr();
    clearClozeUI();

    const id = state.currentSceneId || '';
    const lvl = pickLevelFromId(id);
    if(el.lvlChip) el.lvlChip.textContent = lvl;

    const m = String(id).match(/^w(\d+)\./i);
    if(el.wkTag) el.wkTag.textContent = m ? ('W'+m[1]) : 'W?';

    const sceneTitle = (state.index?.scenes?.find(s=>s.id===id)?.title) || state.scene?.title_en || state.scene?.scene || id;
    setTitle(sceneTitle);

    if(state.aiIdx>=0){
      const a = state.dialogue[state.aiIdx];
      if(el.aiEn) el.aiEn.textContent = a.en || '...';
      if(el.aiZh) el.aiZh.textContent = a.zh || '';
      setMeta(`æœ¬é€±ï¼š${state.scene?.week || m?.[1] || '?'}ï½œTrackï¼š${state.scene?.track || ''}ï½œ${id}`);
    }else{
      if(el.aiEn) el.aiEn.textContent = '...';
      if(el.aiZh) el.aiZh.textContent = '';
      setMeta(`è®€å–å ´æ™¯ï¼š${id}`);
    }

    // your reply zone: show last submitted, otherwise dash
    if(el.qText){
      el.qText.textContent = state.lastUserText ? state.lastUserText : 'â€”';
    }
  }

  function renderHintToInput(){
    if(state.userIdx<0) return showErr('æ­¤å ´æ™¯æ²’æœ‰ USER hintï¼ˆdialogue è£¡æ‰¾ä¸åˆ° speaker=USERï¼‰ã€‚');
    const u = state.dialogue[state.userIdx];
    const full = u.hint_en || '';
    if(!full) return showErr('æ­¤ USER æ²’æœ‰ hint_enã€‚');
    el.userInput.value = full;
    el.userInput.focus();
  }

  // ===== Cloze (deterministic, index-only source = hint_en) =====
  const STOP = new Set(['a','an','the','to','of','in','on','at','for','and','or','but','is','am','are','was','were','be','been','being','i','you','he','she','it','we','they','me','my','your','him','her','us','them','this','that','these','those','please']);
  function tokenizeWords(s){
    // keep contractions, strip punctuation
    return String(s||'')
      .replace(/[â€œâ€]/g,'"')
      .replace(/[â€˜â€™]/g,"'")
      .replace(/[^A-Za-z0-9' ]+/g,' ')
      .trim()
      .split(/\s+/)
      .filter(Boolean);
  }
  function pickBlankWord(words){
    // pick first non-stop word with length>=3, else fallback to middle
    for(const w of words){
      const lw = w.toLowerCase();
      if(lw.length>=3 && !STOP.has(lw)) return w;
    }
    return words[Math.floor(words.length/2)] || '';
  }
  function uniqueLower(arr){
    const out=[]; const seen=new Set();
    for(const x of arr){
      const k=String(x||'').toLowerCase();
      if(!k || seen.has(k)) continue;
      seen.add(k); out.push(x);
    }
    return out;
  }
  function buildClozeOptions(answer, fullSentence){
    const pool = uniqueLower(tokenizeWords(fullSentence).filter(w=>w.toLowerCase()!==answer.toLowerCase()));
    const extra = ['help','gate','terminal','passport','reservation','check','boarding','baggage','menu','order','coffee','hotel','room','key','receipt'];
    const distractors = [];
    for(const w of pool){
      if(distractors.length>=2) break;
      if(!STOP.has(w.toLowerCase())) distractors.push(w);
    }
    for(const w of extra){
      if(distractors.length>=2) break;
      if(w.toLowerCase()!==answer.toLowerCase() && !distractors.some(d=>d.toLowerCase()===w.toLowerCase())) distractors.push(w);
    }
    const opts = uniqueLower([answer, ...distractors]).slice(0,3);
    // deterministic order: answer first then distractors
    return opts;
  }

  function makeCloze(){
    if(state.userIdx<0) return showErr('æ²’æœ‰å¯ç”¨çš„ USER hintï¼Œç„¡æ³•åšå¡«ç©ºå¼•å°ã€‚');
    const u = state.dialogue[state.userIdx];
    const full = u.hint_en || '';
    if(!full) return showErr('æ­¤ USER æ²’æœ‰ hint_enï¼Œç„¡æ³•åšå¡«ç©ºå¼•å°ã€‚');

    const words = tokenizeWords(full);
    if(words.length<3) return showErr('å¥å­å¤ªçŸ­ï¼Œç„¡æ³•åšå¡«ç©ºå¼•å°ã€‚');

    const answer = pickBlankWord(words);
    if(!answer) return showErr('æ‰¾ä¸åˆ°å¯æŒ–ç©ºçš„å­—ã€‚');

    // replace first occurrence (word boundary, case-insensitive) with ___
    const re = new RegExp(`\\b${answer.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')}\\b`, 'i');
    const tmpl = full.replace(re, '___');

    state.cloze = { tmpl, answer, options: buildClozeOptions(answer, full), full };
    // Show template in qText immediately (your requirement)
    state.lastUserText = tmpl;
    if(el.qText) el.qText.textContent = tmpl;

    renderClozeUI(state.cloze);
  }

  function renderClozeUI(c){
    // Minimal chips UI: reuse "æ”¶è—" button area? We'll inject right under qText by using errBox as container? No.
    // Create a small chips row dynamically under helpText (safe).
    let box = document.getElementById('clozeBox');
    if(!box){
      box = document.createElement('div');
      box.id = 'clozeBox';
      box.style.display = 'flex';
      box.style.gap = '8px';
      box.style.flexWrap = 'wrap';
      box.style.margin = '10px 0 2px';
      // insert after qText
      el.qText?.insertAdjacentElement('afterend', box);
    }
    box.innerHTML = '';
    const opts = (c.options||[]).slice(0,3);
    for(const opt of opts){
      const b = document.createElement('button');
      b.type='button';
      b.textContent = opt;
      b.style.border = '1px solid var(--line)';
      b.style.background = '#fff';
      b.style.borderRadius = '999px';
      b.style.padding = '8px 12px';
      b.style.fontWeight = '900';
      b.style.cursor = 'pointer';
      b.addEventListener('click', ()=>{
        el.userInput.value = opt;
        el.userInput.focus();
      });
      box.appendChild(b);
    }
    box.style.display = 'flex';
  }
  function clearClozeUI(){
    state.cloze = null;
    const box = document.getElementById('clozeBox');
    if(box){ box.style.display='none'; box.innerHTML=''; }
  }

  function submitUser(){
    clearErr();
    const input = (el.userInput.value||'').trim();
    if(!input){
      showErr('è«‹å…ˆè¼¸å…¥æˆ–ç”¨å¡«ç©ºå¼•å°é¸å­—ã€‚');
      return;
    }
    if(state.cloze){
      // fill blank deterministically
      const filled = state.cloze.tmpl.replace('___', input);
      state.lastUserText = filled;
      if(el.qText) el.qText.textContent = filled;
    }else{
      state.lastUserText = input;
      if(el.qText) el.qText.textContent = input;
    }
    el.userInput.value = '';
    clearClozeUI();

    // advance to next AI/USER after current user
    const nextFrom = (state.userIdx>=0) ? (state.userIdx+1) : (state.aiIdx>=0 ? state.aiIdx+1 : 0);
    moveToNextPair(nextFrom);
    renderCurrent();
    speakCurrentAI();
  }

  function resetSceneProgress(){
    state.lastUserText = '';
    clearClozeUI();
    moveToNextPair(0);
    renderCurrent();
    speakCurrentAI();
  }

  // ===== TTS =====
  function speak(text){
    try{
      if(!text) return;
      if(!('speechSynthesis' in window)) return;
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'en-US';
      u.rate = 1;
      window.speechSynthesis.speak(u);
    }catch(err){
      console.error(err);
      showErr('TTS å¤±æ•—ï¼š' + (err.message||String(err)));
    }
  }
  function speakCurrentAI(){
    if(state.aiIdx<0) return;
    const a = state.dialogue[state.aiIdx];
    speak(a.en||'');
  }

  // ===== Loaders (MODE 1: only load selected scene json) =====
  async function loadIndex(){
    setLoading('Loading...');
    try{
      const res = await fetch(indexURL.toString(), {cache:'no-store'});
      if(!res.ok) throw new Error(`index.json HTTP ${res.status}`);
      const data = await res.json();
      if(!data || !Array.isArray(data.scenes)) throw new Error('index.json format error (need {scenes:[]})');
      state.index = data;

      if(el.sceneSel){
        el.sceneSel.innerHTML = '';
        for(const s of data.scenes){
          const opt = document.createElement('option');
          opt.value = s.id;
          opt.textContent = s.title || s.id;
          el.sceneSel.appendChild(opt);
        }
      }

      const initial = getInitialSceneId() || (data.scenes[0] && data.scenes[0].id);
      if(initial){
        if(el.sceneSel) el.sceneSel.value = initial;
        await loadScene(initial);
        return;
      }
      setLoading('Loading... (æ²’æœ‰ scenes)');
    }catch(err){
      console.error(err);
      showErr('ç„¡æ³•è®€å– /talk/index.jsonï¼š' + (err.message||String(err)));
      setLoading('Loading... (ç„¡æ³•è®€å– index.json)');
    }
  }

  async function loadScene(id){
    clearErr();
    state.currentSceneId = id;
    setQueryScene(id);

    if(el.lvlChip) el.lvlChip.textContent = pickLevelFromId(id);
    if(el.sceneTitle) el.sceneTitle.textContent = (state.index?.scenes?.find(s=>s.id===id)?.title) || id;

    if(el.aiEn) el.aiEn.textContent = 'Loading...';
    if(el.aiZh) el.aiZh.textContent = `è®€å– ${id}.jsonâ€¦`;
    setMeta(`è®€å– ${id}.jsonâ€¦`);

    try{
      const res = await fetch(sceneURL(id).toString(), {cache:'no-store'});
      if(!res.ok) throw new Error(`${id}.json HTTP ${res.status}`);
      const data = await res.json();
      if(!data) throw new Error('scene json empty');

      const rawDlg = Array.isArray(data.dialogue) ? data.dialogue : (Array.isArray(data.lines) ? data.lines : []);
      if(!Array.isArray(rawDlg) || rawDlg.length===0) throw new Error('scene json format error (need dialogue[])');

      state.scene = data;
      state.dialogue = rawDlg.map(normalizeDialogueItem);

      // MODE 1: only current scene loaded; reset pointer
      state.lastUserText = '';
      moveToNextPair(0);
      renderCurrent();
      speakCurrentAI();
    }catch(err){
      console.error(err);
      showErr(`è®€å– ${id}.json å¤±æ•—ï¼š` + (err.message||String(err)));
      if(el.aiEn) el.aiEn.textContent = 'Loading...';
      if(el.aiZh) el.aiZh.textContent = '';
      setMeta(`è®€å–å¤±æ•—ï¼š${id}.json`);
      clearClozeUI();
    }
  }

  // ===== Wire UI =====
  function initUI(){
    if(el.sceneSel){
      el.sceneSel.addEventListener('change', async()=>{ await loadScene(el.sceneSel.value); });
    }
    if(el.btnReplay) el.btnReplay.addEventListener('click', ()=> speakCurrentAI());
    if(el.btnCloze) el.btnCloze.addEventListener('click', ()=> makeCloze());
    if(el.btnHint) el.btnHint.addEventListener('click', ()=> renderHintToInput());
    if(el.btnSkip) el.btnSkip.addEventListener('click', ()=>{
      clearClozeUI();
      const nextFrom = (state.userIdx>=0) ? (state.userIdx+1) : (state.aiIdx>=0 ? state.aiIdx+1 : 0);
      moveToNextPair(nextFrom);
      renderCurrent();
      speakCurrentAI();
    });
    if(el.btnSubmit) el.btnSubmit.addEventListener('click', ()=> submitUser());
    if(el.userInput){
      el.userInput.addEventListener('keydown', (e)=>{
        if(e.key==='Enter'){ e.preventDefault(); submitUser(); }
      });
    }
    if(el.btnRetry) el.btnRetry.addEventListener('click', ()=> resetSceneProgress());
    if(el.btnFocus) el.btnFocus.addEventListener('click', ()=> el.userInput?.focus());
    if(el.btnBack) el.btnBack.addEventListener('click', ()=> history.back());

    if(el.btnAdmin && el.adminBox){
      el.btnAdmin.addEventListener('click', ()=>{
        el.adminBox.classList.toggle('show');
      });
    }
    // hide
    if(el.btnHide){
      el.btnHide.addEventListener('click', ()=>{
        const reply = document.querySelector('.reply');
        if(!reply) return;
        const on = reply.style.display !== 'none';
        reply.style.display = on ? 'none' : '';
      });
    }

    // Optional: offline upload for testing (Admin)
    if(el.fileIndex){
      el.fileIndex.addEventListener('change', async(e)=>{
        const f = e.target.files && e.target.files[0];
        if(!f) return;
        try{
          const text = await f.text();
          const data = JSON.parse(text);
          if(!Array.isArray(data.scenes)) throw new Error('index json must have scenes[]');
          state.index = data;
          // refill select
          if(el.sceneSel){
            el.sceneSel.innerHTML='';
            for(const s of data.scenes){
              const opt=document.createElement('option');
              opt.value=s.id;
              opt.textContent=s.title||s.id;
              el.sceneSel.appendChild(opt);
            }
          }
          const initial = (data.scenes[0] && data.scenes[0].id) || '';
          if(initial){ el.sceneSel.value=initial; await loadScene(initial); }
        }catch(err){
          showErr('é›¢ç·š index.json è§£æå¤±æ•—ï¼š'+(err.message||String(err)));
        }
      });
    }
    if(el.fileScene){
      el.fileScene.addEventListener('change', async(e)=>{
        const f = e.target.files && e.target.files[0];
        if(!f) return;
        try{
          const text = await f.text();
          const data = JSON.parse(text);
          state.scene=data;
          const rawDlg = Array.isArray(data.dialogue) ? data.dialogue : (Array.isArray(data.lines)?data.lines:[]);
          state.dialogue = rawDlg.map(normalizeDialogueItem);
          state.lastUserText='';
          moveToNextPair(0);
          renderCurrent();
        }catch(err){
          showErr('é›¢ç·š scene.json è§£æå¤±æ•—ï¼š'+(err.message||String(err)));
        }
      });
    }
  }

  initUI();
  loadIndex();

})();
</script>

</body>
</html>
